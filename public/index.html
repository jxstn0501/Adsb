<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Heli Tracker</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#6F5DF7" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Heli Tracker" />
  <meta name="application-name" content="Heli Tracker" />
  <meta name="format-detection" content="telephone=no" />
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/180.png" />
  <link rel="apple-touch-icon" sizes="512x512" href="/icons/512.png" />
  <link rel="manifest" href="/manifest.json" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            sans: ['Inter', 'ui-sans-serif', 'system-ui']
          },
          colors: {
            brand: {
              red: '#D93030',
              purple: '#6F5DF7',
              ink: '#1C1C1E',
              frost: '#F5F5F7'
            }
          },
          boxShadow: {
            card: '0 12px 32px rgba(28, 28, 30, 0.08)',
            glass: '0 20px 40px rgba(111, 93, 247, 0.18)'
          }
        }
      }
    };
  </script>
  <style>
    :root {
      color-scheme: light;
      --safe-area-top-fallback: 0px;
      --safe-area-bottom-fallback: 0px;
      --app-content-offset: calc(var(--safe-area-top-fallback) + 6.5rem);
      --app-nav-height: 6.75rem;
      --app-nav-height-fallback: 6.75rem;
    }

    @supports (padding-top: env(safe-area-inset-top)) {
      :root {
        --app-content-offset: calc(env(safe-area-inset-top) + 6.5rem);
      }
    }

    @supports (padding-top: constant(safe-area-inset-top)) {
      :root {
        --app-content-offset: calc(constant(safe-area-inset-top) + 6.5rem);
      }
    }

    .view-panel {
      animation: fadeInUp 0.45s ease forwards;
    }

    .nav-active-icon {
      animation: navPulse 0.55s ease;
    }

    .safe-area-top {
      padding-top: calc(var(--safe-area-top-fallback) + 1rem);
      padding-top: calc(env(safe-area-inset-top, 0px) + 1rem);
    }

    @supports (padding-top: constant(safe-area-inset-top)) {
      .safe-area-top {
        padding-top: calc(constant(safe-area-inset-top) + 1rem);
      }
    }

    .safe-area-bottom {
      padding-bottom: var(--safe-area-bottom-fallback);
      padding-bottom: env(safe-area-inset-bottom, 0px);
    }

    @supports (padding-bottom: constant(safe-area-inset-bottom)) {
      .safe-area-bottom {
        padding-bottom: constant(safe-area-inset-bottom);
      }
    }

    .app-header {
      position: fixed;
      left: 0;
      right: 0;
      top: 0;
    }

    .app-content {
      padding-top: var(--app-content-offset);
      padding-bottom: calc(var(--app-nav-height, 6.75rem) + var(--safe-area-bottom-fallback));
      padding-bottom: calc(var(--app-nav-height, 6.75rem) + env(safe-area-inset-bottom, 0px));
    }

    @supports (padding-top: constant(safe-area-inset-top)) {
      :root {
        --app-content-offset: calc(constant(safe-area-inset-top) + 6.5rem);
      }
    }

    @supports (padding-bottom: constant(safe-area-inset-bottom)) {
      .app-content {
        padding-bottom: calc(var(--app-nav-height-fallback, var(--app-nav-height, 6.75rem)) + constant(safe-area-inset-bottom));
      }
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(16px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes navPulse {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.12);
      }
      100% {
        transform: scale(1);
      }
    }

    @media (max-width: 430px) {
      html {
        font-size: clamp(16px, 4vw, 18px);
      }

      .view-panel {
        padding-left: 0.25rem;
        padding-right: 0.25rem;
      }

      .app-nav {
        border-radius: 1.5rem;
        gap: 0.75rem;
        padding: 0.75rem;
      }

      .nav-item {
        border-radius: 1.25rem;
        gap: 0.35rem;
        padding: 0.4rem 0.65rem;
      }

      .nav-item .nav-icon {
        height: 2.75rem;
        width: 2.75rem;
      }

      .text-xs {
        font-size: 0.82rem !important;
      }

      .text-sm {
        font-size: 0.92rem !important;
      }

      .text-\[0\.65rem\] {
        font-size: 0.75rem !important;
      }

      .text-\[0\.6rem\] {
        font-size: 0.7rem !important;
      }
    }
  </style>
  <script>
    const ensureTopOnLoad = () => {
      window.scrollTo({ top: 0, left: 0, behavior: "auto" });
    };

    let headerResizeObserver;
    let layoutRefreshTimer = null;

    const updateSafeAreaFallbacks = () => {
      const root = document.documentElement;
      if (!root || !window.visualViewport) {
        return;
      }

      const viewport = window.visualViewport;
      const topInset = Math.max(0, Math.round(viewport.offsetTop));
      const bottomInset = Math.max(
        0,
        Math.round(window.innerHeight - viewport.height - viewport.offsetTop)
      );

      root.style.setProperty("--safe-area-top-fallback", `${topInset}px`);
      root.style.setProperty("--safe-area-bottom-fallback", `${bottomInset}px`);
    };

    const updateLayoutOffsets = () => {
      const root = document.documentElement;
      if (!root) {
        return;
      }

      const header = document.querySelector(".app-header");
      if (header) {
        const headerHeight = header.getBoundingClientRect().height;
        if (headerHeight > 0) {
          root.style.setProperty("--app-content-offset", `${headerHeight}px`);
        }
      }

      const nav = document.querySelector(".app-nav");
      if (nav) {
        const navHeight = nav.getBoundingClientRect().height;
        if (navHeight > 0) {
          const computedNavPadding = Math.max(28, Math.round(navHeight * 0.2));
          const offset = Math.round(navHeight + computedNavPadding);
          root.style.setProperty("--app-nav-height", `${offset}px`);
          root.style.setProperty("--app-nav-height-fallback", `${offset}px`);
        }
      }
    };

    const initializeLayout = () => {
      ensureTopOnLoad();
      updateSafeAreaFallbacks();
      updateLayoutOffsets();

      if ("ResizeObserver" in window) {
        const targets = [
          document.querySelector(".app-header"),
          document.querySelector(".app-nav")
        ].filter(Boolean);

        if (targets.length > 0) {
          if (!headerResizeObserver) {
            headerResizeObserver = new ResizeObserver(() => {
              updateLayoutOffsets();
            });
          }

          targets.forEach(target => {
            try {
              headerResizeObserver.observe(target);
            } catch (err) {
              // ignore observer errors for unsupported targets
            }
          });
        }
      }
    };

    const refreshLayoutAfterKeyboardInteraction = () => {
      updateSafeAreaFallbacks();
      window.requestAnimationFrame(updateLayoutOffsets);
      if (layoutRefreshTimer) {
        clearTimeout(layoutRefreshTimer);
      }
      layoutRefreshTimer = window.setTimeout(() => {
        layoutRefreshTimer = null;
        updateSafeAreaFallbacks();
        window.requestAnimationFrame(updateLayoutOffsets);
      }, 250);
    };

    window.addEventListener("DOMContentLoaded", initializeLayout);
    window.addEventListener("pageshow", ensureTopOnLoad);
    window.addEventListener("load", () => {
      updateSafeAreaFallbacks();
      updateLayoutOffsets();
    });
    window.addEventListener("resize", () => {
      updateSafeAreaFallbacks();
      window.requestAnimationFrame(updateLayoutOffsets);
    });
    window.addEventListener("focusin", refreshLayoutAfterKeyboardInteraction);
    window.addEventListener("focusout", refreshLayoutAfterKeyboardInteraction);
    window.addEventListener("orientationchange", () => {
      updateSafeAreaFallbacks();
      window.requestAnimationFrame(updateLayoutOffsets);
    });

    if (window.visualViewport) {
      window.visualViewport.addEventListener("resize", () => {
        updateSafeAreaFallbacks();
        window.requestAnimationFrame(updateLayoutOffsets);
      });
      window.visualViewport.addEventListener("scroll", () => {
        updateSafeAreaFallbacks();
        window.requestAnimationFrame(updateLayoutOffsets);
      });
    }
  </script>
</head>
<body class="min-h-screen bg-brand-frost font-sans text-brand-ink antialiased">
  <div class="flex min-h-[100dvh] flex-col">
    <header class="app-header z-40 bg-gradient-to-r from-brand-purple via-brand-red to-brand-purple px-4 py-3 safe-area-top text-white shadow-lg shadow-brand-red/30 sm:px-5">
      <div class="mx-auto flex w-full max-w-6xl flex-col gap-3 sm:flex-row sm:items-center">
        <div class="space-y-0.5">
          <p class="text-[0.7rem] uppercase tracking-[0.45em] text-white/70 sm:text-[0.6rem]">Control Center</p>
          <h1 class="text-xl font-semibold leading-snug">Heli Tracker</h1>
        </div>
        <div class="flex flex-1 items-start justify-between gap-3 sm:items-center sm:justify-end">
          <div class="hidden text-right sm:block">
            <p id="viewTitle" class="text-[0.7rem] uppercase tracking-[0.4em] text-white/70 sm:text-[0.6rem]">Map</p>
            <p class="text-[0.8rem] font-medium text-white/90 sm:text-xs">Live monitoring</p>
          </div>
          <div class="flex flex-col items-end gap-2 sm:flex-row sm:items-center sm:gap-3">
            <div id="headerCallsign" class="rounded-full bg-white/20 px-4 py-1.5 text-[0.8rem] font-semibold uppercase tracking-[0.35em] text-white/90 sm:ml-auto sm:text-[0.7rem]">
              —
            </div>
            <span
              id="flightStatusBadge"
              class="inline-flex items-center rounded-full border border-white/30 bg-white/10 px-4 py-1 text-[0.75rem] font-semibold uppercase tracking-[0.35em] text-white/70 sm:text-[0.6rem]"
            >
              —
            </span>
          </div>
        </div>
      </div>
    </header>

    <main id="content" class="app-content relative flex-1 min-w-0 overflow-y-auto px-4 sm:px-6 lg:px-8">
      <div class="flex h-full items-center justify-center">
        <div class="rounded-2xl bg-white/80 px-5 py-4 text-base font-medium text-slate-600 shadow-card backdrop-blur sm:px-6 sm:py-5">
          Lade Daten...
        </div>
      </div>
    </main>

    <nav class="pointer-events-none fixed inset-x-0 bottom-0 z-30 px-4 safe-area-bottom">
      <div class="app-nav pointer-events-auto mx-auto flex w-full max-w-3xl items-center justify-around gap-3 rounded-3xl border border-white/60 bg-white/70 px-2.5 py-2 shadow-glass backdrop-blur-xl sm:px-3">
        <button type="button" data-view="dashboard" onclick="showDashboard()" class="nav-item group flex flex-1 flex-col items-center gap-1 rounded-2xl px-2.5 py-1.5 text-[0.8rem] font-semibold text-slate-500 transition-all duration-300 ease-out focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/40 sm:px-3 sm:py-2 sm:text-[0.7rem]">
          <span class="nav-icon flex h-10 w-10 items-center justify-center rounded-2xl bg-white/60 text-slate-500 transition-all duration-300 ease-out group-hover:scale-105 group-hover:shadow-lg sm:h-11 sm:w-11">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-5 w-5">
              <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75h7.5v7.5h-7.5zM12.75 3.75h7.5v7.5h-7.5zM3.75 12.75h7.5v7.5h-7.5zM12.75 12.75h7.5v7.5h-7.5z" />
            </svg>
          </span>
          <span>Dashboard</span>
        </button>
        <button type="button" data-view="map" onclick="showADSB()" class="nav-item group flex flex-1 flex-col items-center gap-1 rounded-2xl px-2.5 py-1.5 text-[0.8rem] font-semibold text-slate-500 transition-all duration-300 ease-out focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/40 sm:px-3 sm:py-2 sm:text-[0.7rem]">
          <span class="nav-icon flex h-10 w-10 items-center justify-center rounded-2xl bg-white/60 text-slate-500 transition-all duration-300 ease-out group-hover:scale-105 group-hover:shadow-lg sm:h-11 sm:w-11">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-5 w-5">
              <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12l8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12m-1.5 0v8.25a1.5 1.5 0 01-1.5 1.5h-3.75m-9 0H3.75a1.5 1.5 0 01-1.5-1.5V12" />
            </svg>
          </span>
          <span>Map</span>
        </button>
        <button type="button" data-view="events" onclick="showEvents()" class="nav-item group flex flex-1 flex-col items-center gap-1 rounded-2xl px-2.5 py-1.5 text-[0.8rem] font-semibold text-slate-500 transition-all duration-300 ease-out focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/40 sm:px-3 sm:py-2 sm:text-[0.7rem]">
          <span class="nav-icon flex h-10 w-10 items-center justify-center rounded-2xl bg-white/60 text-slate-500 transition-all duration-300 ease-out group-hover:scale-105 group-hover:shadow-lg sm:h-11 sm:w-11">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-5 w-5">
              <path stroke-linecap="round" stroke-linejoin="round" d="M3 4.5h18m-16.5 6h15m-13.5 6h12" />
            </svg>
          </span>
          <span>Events</span>
        </button>
        <button type="button" data-view="settings" onclick="showSettings()" class="nav-item group flex flex-1 flex-col items-center gap-1 rounded-2xl px-2.5 py-1.5 text-[0.8rem] font-semibold text-slate-500 transition-all duration-300 ease-out focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/40 sm:px-3 sm:py-2 sm:text-[0.7rem]">
          <span class="nav-icon flex h-10 w-10 items-center justify-center rounded-2xl bg-white/60 text-slate-500 transition-all duration-300 ease-out group-hover:scale-105 group-hover:shadow-lg sm:h-11 sm:w-11">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-5 w-5">
              <path stroke-linecap="round" stroke-linejoin="round" d="M11.25 4.5l.41-1.233A.75.75 0 0112.38 3h.24a.75.75 0 01.72.533L13.75 4.5h1.5l.41-1.233A.75.75 0 0116.88 3h.24a.75.75 0 01.72.533L18.25 4.5m-7 16.5l-.41 1.233a.75.75 0 01-.72.533h-.24a.75.75 0 01-.72-.533L8.75 21h-1.5l-.41 1.233a.75.75 0 01-.72.533h-.24a.75.75 0 01-.72-.533L4.75 21m15-16.5H4.25a2.25 2.25 0 00-2.25 2.25v9a2.25 2.25 0 002.25 2.25h15a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25z" />
            </svg>
          </span>
          <span>Settings</span>
        </button>
      </div>
    </nav>
  </div>

  <script>
    const DEFAULT_PLACE_RADIUS_FALLBACK_METERS = 500;
    const DEFAULT_ALTITUDE_THRESHOLD_FT = 300;
    const DEFAULT_SPEED_THRESHOLD_KT = 40;
    const DEFAULT_OFFLINE_TIMEOUT_SEC = 60;
    const LOG_SOURCE_LIVE = "live";
    const LOG_SOURCE_HISTORY = "history";
    const LOG_HISTORY_LIMIT_DAYS = 14;
    const LOG_DETAIL_ROW_LIMIT = 200;
    const logOverviewCache = {
      [LOG_SOURCE_LIVE]: [],
      [LOG_SOURCE_HISTORY]: []
    };
    let currentHex = "";
    let hexInputDirty = false;
    let currentCallsign = "";
    let settingsInterval = null;
    let currentConfigCache = null;
    let currentPlaces = [];
    let currentEvents = [];
    let currentAircraft = [];
    let editingPlaceId = null;
    let editingAircraftHex = null;
    let nominatimResults = [];
    let nominatimSelectedIndex = null;
    let nominatimSearchToken = 0;
    let activeView = "map";
    let activeEventMap = null;
    let currentEventGroups = [];
    let activeEventGroupKey = null;
    let cachedLogOverview = [];
    let activeLogSource = LOG_SOURCE_LIVE;
    let activeLogHex = null;
    let activeSettingsSection = "aircraft";
    let dashboardMapCurrentHex = "";
    let dashboardRefreshTimer = null;
    let dashboardChartInstance = null;
    let latestTelemetry = null;
    let lastWeatherFetch = { lat: null, lon: null, timestamp: 0 };
    let lastWeatherData = null;
    const GEOLOCATION_SUPPORTED = typeof navigator !== "undefined" && !!(navigator && navigator.geolocation);
    let deviceLocationStatus = GEOLOCATION_SUPPORTED ? "idle" : "unsupported";
    let deviceLocation = null;
    let deviceLocationError = null;
    let deviceLocationWatchId = null;
    let deviceLocationInitialized = false;
    let dashboardMapCurrentConfigKey = "";
    let mapViewCurrentConfigKey = "";
    const ADSB_DEFAULT_ZOOM = 9;
    const EVENTS_VIEW_OVERVIEW = "overview";
    const EVENTS_VIEW_GROUP = "group";
    const EVENTS_VIEW_DETAIL = "detail";

    let eventDetailReturnState = { mode: EVENTS_VIEW_OVERVIEW, groupKey: null };
    let eventsOverviewScrollTop = 0;
    const eventGroupScrollPositions = new Map();
    const EVENT_STREAM_RETRY_MS = 5000;
    const DEFAULT_NOTIFICATION_SETTINGS = {
      enabled: false,
      notifyOnTakeoff: true,
      notifyOnLanding: true
    };
    const NOTIFICATION_EVENT_TYPES = new Set(["takeoff", "landing"]);
    let notificationPreferences = { ...DEFAULT_NOTIFICATION_SETTINGS };
    const NOTIFICATION_DEBUG_STORAGE_KEY = "heli-tracker-debug-notifications";
    let notificationPreferencesReady = false;
    let notificationPreferencesReadyPromise = null;
    let notificationDebugMode = loadNotificationDebugMode();
    let serviceWorkerReadyPromise = null;
    let eventStreamSource = null;
    let eventStreamReconnectTimer = null;
    let lastReceivedEventId = null;
    let activeEventDetail = null;
    let debugNotificationTimer = null;
    let pendingNotificationNavigation = null;
    const navInactiveButtonClasses = ["text-slate-500", "bg-transparent", "shadow-none", "scale-100"];
    const navActiveButtonClasses = [
      "text-brand-purple",
      "bg-white",
      "shadow-[0_12px_28px_rgba(111,93,247,0.28)]",
      "scale-[1.05]"
    ];
    const navInactiveIconClasses = ["bg-white/60", "text-slate-500", "shadow-none"];
    const navActiveIconClasses = [
      "bg-gradient-to-br",
      "from-brand-purple/20",
      "via-white",
      "to-brand-red/20",
      "text-brand-purple",
      "shadow-[0_10px_24px_rgba(111,93,247,0.35)]"
    ];
    const logSourceActiveClasses = [
      "bg-brand-purple",
      "text-white",
      "shadow-card"
    ];
    const logSourceInactiveClasses = [
      "bg-white/70",
      "text-slate-500",
      "shadow-inner",
      "shadow-white/60"
    ];
    const settingsSectionOrder = ["aircraft", "thresholds", "notifications", "places", "events", "logs"];
    const settingsTabActiveClasses = [
      "border-brand-purple/40",
      "bg-white",
      "text-brand-purple",
      "shadow-[0_12px_28px_rgba(111,93,247,0.18)]"
    ];
    const settingsTabInactiveClasses = [
      "border-transparent",
      "bg-white/60",
      "text-slate-500"
    ];
    const DASHBOARD_REFRESH_INTERVAL_MS = 20000;
    const WEATHER_REFRESH_INTERVAL_MS = 5 * 60 * 1000;
    const viewTitleMap = {
      dashboard: "Dashboard",
      map: "Live Map",
      events: "Events",
      settings: "Settings"
    };

    window.addEventListener("DOMContentLoaded", () => {
      pendingNotificationNavigation = extractPendingEventFromUrl();
      setupServiceWorkerMessageListener();
      void initializeTracker();
    });

    function scrollViewportToTop(target) {
      if (target) {
        target.scrollTop = 0;
        requestAnimationFrame(() => {
          target.scrollTop = 0;
        });
      }
      window.scrollTo({ top: 0, left: 0, behavior: "auto" });
    }

    function formatDateTime(value) {
      if (!value && value !== 0) {
        return "—";
      }
      const date = value instanceof Date ? value : new Date(value);
      if (Number.isNaN(date.getTime())) {
        if (typeof value === "string" && value.trim()) {
          return value.trim();
        }
        return String(value ?? "—");
      }

      const day = String(date.getDate()).padStart(2, "0");
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const year = date.getFullYear();
      const hours = String(date.getHours()).padStart(2, "0");
      const minutes = String(date.getMinutes()).padStart(2, "0");

      return `${day}.${month}.${year} ${hours}:${minutes}`;
    }

    function isGeolocationSupported() {
      return GEOLOCATION_SUPPORTED;
    }

    function setupDeviceLocationUI() {
      const button = document.getElementById("deviceLocationButton");
      if (button) {
        button.addEventListener("click", event => {
          event.preventDefault();
          requestDeviceLocationAccess();
        });
      }
      updateDeviceLocationNotice();
    }

    function initializeDeviceLocationTracking() {
      if (deviceLocationInitialized) {
        return;
      }
      deviceLocationInitialized = true;

      if (!isGeolocationSupported()) {
        deviceLocationStatus = "unsupported";
        updateDeviceLocationNotice();
        return;
      }

      updateDeviceLocationNotice();

      if (navigator.permissions && navigator.permissions.query) {
        try {
          navigator.permissions
            .query({ name: "geolocation" })
            .then(status => {
              handleDeviceLocationPermission(status);
              const listener = () => handleDeviceLocationPermission(status);
              if (typeof status.addEventListener === "function") {
                status.addEventListener("change", listener);
              } else {
                status.onchange = listener;
              }
            })
            .catch(() => {
              // Permissions API nicht verfügbar oder verweigert
            });
        } catch (err) {
          // Ignorieren, wenn Zugriff auf Permissions API fehlschlägt
        }
      }
    }

    function handleDeviceLocationPermission(status) {
      if (!status) {
        return;
      }

      const state = status.state || status.status;
      if (state === "granted") {
        startDeviceLocationWatch({ force: true });
      } else if (state === "denied") {
        stopDeviceLocationWatch();
        deviceLocationStatus = "denied";
        deviceLocation = null;
        deviceLocationError = null;
        updateDeviceLocationNotice();
        refreshFlightDistance();
        refreshAdsbExchangeFrames();
      } else {
        deviceLocationStatus = "idle";
        updateDeviceLocationNotice();
      }
    }

    function requestDeviceLocationAccess() {
      deviceLocationError = null;
      startDeviceLocationWatch({ force: true });
    }

    function startDeviceLocationWatch(options = {}) {
      if (!isGeolocationSupported()) {
        deviceLocationStatus = "unsupported";
        updateDeviceLocationNotice();
        return;
      }

      const { force = false } = options;

      if (deviceLocationWatchId !== null) {
        if (!force) {
          return;
        }
        stopDeviceLocationWatch();
      }

      const geo = navigator.geolocation;
      if (!geo) {
        deviceLocationStatus = "unsupported";
        updateDeviceLocationNotice();
        return;
      }

      deviceLocationStatus = "requesting";
      updateDeviceLocationNotice();

      const successHandler = position => {
        deviceLocationStatus = "active";
        applyDeviceLocation(position);
      };

      const errorHandler = error => {
        handleDeviceLocationError(error);
      };

      try {
        deviceLocationWatchId = geo.watchPosition(successHandler, errorHandler, {
          enableHighAccuracy: true,
          maximumAge: 15000,
          timeout: 20000
        });
      } catch (err) {
        handleDeviceLocationError(err);
        return;
      }

      try {
        geo.getCurrentPosition(successHandler, errorHandler, {
          enableHighAccuracy: true,
          maximumAge: 15000,
          timeout: 10000
        });
      } catch (err) {
        handleDeviceLocationError(err);
      }
    }

    function stopDeviceLocationWatch() {
      if (deviceLocationWatchId !== null && navigator.geolocation) {
        try {
          navigator.geolocation.clearWatch(deviceLocationWatchId);
        } catch (err) {
          // Ignorieren, wenn Löschen nicht möglich ist
        }
      }
      deviceLocationWatchId = null;
    }

    function applyDeviceLocation(position) {
      if (!position || !position.coords) {
        return;
      }

      const lat = Number(position.coords.latitude);
      const lon = Number(position.coords.longitude);

      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
        return;
      }

      const accuracy = Number(position.coords.accuracy);
      const timestamp = typeof position.timestamp === "number" ? position.timestamp : Date.now();

      deviceLocation = {
        lat,
        lon,
        accuracy: Number.isFinite(accuracy) ? accuracy : null,
        timestamp
      };
      deviceLocationError = null;
      deviceLocationStatus = "active";

      updateDeviceLocationNotice();
      refreshFlightDistance();
      refreshAdsbExchangeFrames();
    }

    function handleDeviceLocationError(error) {
      deviceLocationError = error || null;

      if (error && typeof error.code === "number") {
        if (error.code === error.PERMISSION_DENIED) {
          deviceLocationStatus = "denied";
          stopDeviceLocationWatch();
          deviceLocation = null;
        } else if (error.code === error.POSITION_UNAVAILABLE || error.code === error.TIMEOUT) {
          deviceLocationStatus = "error";
        } else {
          deviceLocationStatus = "error";
        }
      } else {
        deviceLocationStatus = "error";
      }

      updateDeviceLocationNotice();
      refreshFlightDistance();
      refreshAdsbExchangeFrames();
    }

    function getValidDeviceLocation() {
      if (!deviceLocation || typeof deviceLocation !== "object") {
        return null;
      }
      const lat = Number(deviceLocation.lat);
      const lon = Number(deviceLocation.lon);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
        return null;
      }
      return { lat, lon };
    }

    function refreshFlightDistance() {
      if (typeof updateDashboardFlightMetrics !== "function") {
        return;
      }
      updateDashboardFlightMetrics(latestTelemetry, currentEvents);
    }

    function refreshAdsbExchangeFrames(options = {}) {
      const force = options && options.force === true;
      updateDashboardMapWithLatest(latestTelemetry, { force });
      updateStandaloneMapFrame({ force });
    }

    function buildAdsbExchangeUrl(hex) {
      const normalized = normalizeHex(hex);
      if (!normalized) {
        return "";
      }

      try {
        const url = new URL("https://globe.adsbexchange.com/");
        url.searchParams.set("icao", normalized);
        url.searchParams.set("hideSidebar", "1");
        url.searchParams.set("hideButtons", "1");
        url.searchParams.set("zoom", String(ADSB_DEFAULT_ZOOM));
        return url.toString();
      } catch (err) {
        console.warn("[Map] ADS-B URL konnte nicht erstellt werden:", err);
        const base = `${ADSB_BASE_URL}${encodeURIComponent(normalized)}`;
        const params = new URLSearchParams({
          zoom: String(ADSB_DEFAULT_ZOOM),
          hideSidebar: "1",
          hideButtons: "1"
        });
        return `${base}&${params.toString()}`;
      }
    }

    function updateDeviceLocationNotice() {
      const notice = document.getElementById("deviceLocationNotice");
      const message = document.getElementById("deviceLocationMessage");
      const button = document.getElementById("deviceLocationButton");

      if (!notice || !message) {
        return;
      }

      let buttonLabel = "Standort aktivieren";
      let showButton = true;
      let disableButton = false;
      let text = "Standortzugriff erforderlich, um die Distanz zum Flugzeug zu berechnen.";
      const location = getValidDeviceLocation();

      if (!isGeolocationSupported()) {
        text = "Gerät unterstützt keine Standortabfrage.";
        showButton = false;
      } else if (deviceLocationStatus === "requesting") {
        text = "Standort wird angefragt...";
        buttonLabel = "Wird geladen…";
        disableButton = true;
      } else if (deviceLocationStatus === "active" && location) {
        const accuracy = deviceLocation && Number.isFinite(deviceLocation.accuracy)
          ? Math.round(deviceLocation.accuracy)
          : null;
        const timestamp = deviceLocation && Number.isFinite(deviceLocation.timestamp)
          ? new Date(deviceLocation.timestamp)
          : null;
        const timeLabel = timestamp && !Number.isNaN(timestamp.getTime())
          ? timestamp.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
          : null;
        text = "Standort aktiv.";
        if (accuracy !== null) {
          text += ` Genauigkeit ±${accuracy} m.`;
        }
        if (timeLabel) {
          text += ` Aktualisiert um ${timeLabel}.`;
        }
        showButton = false;
      } else if (deviceLocationStatus === "denied") {
        text = "Standortzugriff wurde verweigert. Bitte Freigabe in den Geräteeinstellungen erteilen.";
        buttonLabel = "Erneut versuchen";
      } else if (deviceLocationStatus === "error") {
        const detail = deviceLocationError && deviceLocationError.message
          ? ` (${deviceLocationError.message})`
          : "";
        text = `Standort konnte nicht ermittelt werden${detail}.`;
        buttonLabel = "Erneut versuchen";
      } else {
        text = "Standortzugriff erforderlich, um die Distanz zum Flugzeug zu berechnen.";
      }

      message.textContent = text;

      if (button) {
        if (showButton) {
          button.classList.remove("hidden");
          button.disabled = disableButton;
          button.textContent = buttonLabel;
        } else {
          button.classList.add("hidden");
          button.disabled = true;
        }
      }
    }

    function formatDateLabel(value) {
      if (typeof value !== "string") {
        return "—";
      }

      const trimmed = value.trim();
      if (!trimmed) {
        return "—";
      }

      const parts = trimmed.split("-");
      if (parts.length === 3) {
        const [year, month, day] = parts;
        return `${day}.${month}.${year}`;
      }

      return trimmed;
    }

    function formatMetricValue(value, suffix) {
      if (value === null || value === undefined) {
        return "—";
      }
      const text = String(value).trim();
      if (!text) {
        return "—";
      }
      return suffix ? `${text} ${suffix}` : text;
    }

    function parseJSONSafe(text) {
      if (typeof text !== "string") {
        return null;
      }
      try {
        return JSON.parse(text);
      } catch (err) {
        return null;
      }
    }

    function extractPendingEventFromUrl() {
      if (typeof window === "undefined" || typeof window.location === "undefined") {
        return null;
      }

      try {
        const url = new URL(window.location.href);
        const params = new URLSearchParams(url.search);
        const payloadParam = params.get("eventPayload");
        const groupKeyParam = params.get("eventGroup") || "";
        const eventIdParam = params.get("eventId") || "";

        if (!payloadParam) {
          return null;
        }

        params.delete("eventPayload");
        params.delete("eventGroup");
        params.delete("eventId");
        url.search = params.toString();

        const newUrl = url.toString();
        if (typeof window.history !== "undefined"
          && window.history
          && typeof window.history.replaceState === "function") {
          try {
            window.history.replaceState({}, document.title, newUrl);
          } catch (err) {
            // ignore history update errors
          }
        }

        let jsonText = payloadParam;
        try {
          jsonText = decodeURIComponent(payloadParam);
        } catch (err) {
          // ignore double decode issues
        }

        try {
          const eventData = JSON.parse(jsonText);
          if (eventData && typeof eventData === "object") {
            return {
              event: eventData,
              groupKey: groupKeyParam || null,
              eventId: eventIdParam || null
            };
          }
        } catch (err) {
          console.warn("[Notifications] Event-Parameter konnten nicht gelesen werden:", err);
        }
      } catch (err) {
        console.warn("[Notifications] Event-URL konnte nicht verarbeitet werden:", err);
      }

      return null;
    }

    function isServiceWorkerSupported() {
      return typeof navigator !== "undefined"
        && "serviceWorker" in navigator
        && typeof navigator.serviceWorker !== "undefined";
    }

    function setupServiceWorkerMessageListener() {
      if (!isServiceWorkerSupported()) {
        return;
      }

      const handler = event => {
        if (!event || !event.data || typeof event.data !== "object") {
          return;
        }

        const { type, event: payload, groupKey } = event.data;
        if (type === "open-event" && payload) {
          openEventDetailFromNotification(payload, groupKey || "");
        }
      };

      navigator.serviceWorker.addEventListener("message", handler);
    }

    function isNotificationApiAvailable() {
      return typeof window !== "undefined"
        && "Notification" in window;
    }

    function isNotificationSupported() {
      return isServiceWorkerSupported() && isNotificationApiAvailable();
    }

    function syncNotificationPreferencesFromConfig(config) {
      const enabled = !!(config && config.notificationsEnabled);
      const takeoff = config && Object.prototype.hasOwnProperty.call(config, "notifyOnTakeoff")
        ? config.notifyOnTakeoff !== false
        : DEFAULT_NOTIFICATION_SETTINGS.notifyOnTakeoff;
      const landing = config && Object.prototype.hasOwnProperty.call(config, "notifyOnLanding")
        ? config.notifyOnLanding !== false
        : DEFAULT_NOTIFICATION_SETTINGS.notifyOnLanding;

      notificationPreferences = {
        enabled,
        notifyOnTakeoff: takeoff,
        notifyOnLanding: landing
      };
      notificationPreferencesReady = true;
    }

    async function ensureServiceWorkerReady() {
      if (!isServiceWorkerSupported()) {
        return null;
      }

      if (!serviceWorkerReadyPromise) {
        serviceWorkerReadyPromise = (async () => {
          try {
            await navigator.serviceWorker.register("/service-worker.js");
          } catch (err) {
            console.warn("[Notifications] Service Worker Registrierung fehlgeschlagen:", err);
          }

          try {
            return await navigator.serviceWorker.ready;
          } catch (err) {
            console.warn("[Notifications] Service Worker wurde nicht aktiv:", err);
            return null;
          }
        })();
      }

      try {
        return await serviceWorkerReadyPromise;
      } catch (err) {
        console.warn("[Notifications] Service Worker konnte nicht vorbereitet werden:", err);
        return null;
      }
    }

    async function ensureNotificationPermission() {
      if (!isNotificationApiAvailable()) {
        return false;
      }

      if (Notification.permission === "granted") {
        return true;
      }

      if (Notification.permission === "denied") {
        return false;
      }

      try {
        const result = await Notification.requestPermission();
        return result === "granted";
      } catch (err) {
        console.warn("[Notifications] Berechtigungsanfrage fehlgeschlagen:", err);
        return false;
      }
    }

    async function ensureNotificationPreferencesReady() {
      if (notificationPreferencesReady) {
        return;
      }

      if (!notificationPreferencesReadyPromise) {
        notificationPreferencesReadyPromise = preloadConfigForNotifications();
      }

      try {
        await notificationPreferencesReadyPromise;
      } catch (err) {
        console.warn("[Notifications] Voreinstellungen konnten nicht geladen werden:", err);
      }
    }

    function loadNotificationDebugMode() {
      try {
        if (typeof window === "undefined" || !window.localStorage) {
          return false;
        }
        const value = window.localStorage.getItem(NOTIFICATION_DEBUG_STORAGE_KEY);
        return value === "1";
      } catch (err) {
        console.warn("[Notifications] Debug-Modus konnte nicht geladen werden:", err);
        return false;
      }
    }

    function saveNotificationDebugMode(enabled) {
      try {
        if (typeof window === "undefined" || !window.localStorage) {
          return;
        }
        if (enabled) {
          window.localStorage.setItem(NOTIFICATION_DEBUG_STORAGE_KEY, "1");
        } else {
          window.localStorage.removeItem(NOTIFICATION_DEBUG_STORAGE_KEY);
        }
      } catch (err) {
        console.warn("[Notifications] Debug-Modus konnte nicht gespeichert werden:", err);
      }
    }

    function preloadConfigForNotifications() {
      return fetchConfig()
        .then(config => {
          currentConfigCache = config;
          syncNotificationPreferencesFromConfig(config);
          return config;
        })
        .catch(err => {
          console.warn("[Notifications] Konfiguration konnte nicht geladen werden:", err);
          notificationPreferences = { ...DEFAULT_NOTIFICATION_SETTINGS };
          notificationPreferencesReady = true;
          return null;
        });
    }

    function buildConfigRequestPayload(overrides = {}) {
      const base = currentConfigCache || {};

      const altitude = parseNumberInput(
        overrides.altitudeThresholdFt !== undefined
          ? overrides.altitudeThresholdFt
          : base.altitudeThresholdFt
      );
      const speed = parseNumberInput(
        overrides.speedThresholdKt !== undefined
          ? overrides.speedThresholdKt
          : base.speedThresholdKt
      );
      const timeout = parseNumberInput(
        overrides.offlineTimeoutSec !== undefined
          ? overrides.offlineTimeoutSec
          : base.offlineTimeoutSec
      );
      const radius = parseNumberInput(
        overrides.placeMatchRadiusMeters !== undefined
          ? overrides.placeMatchRadiusMeters
          : base.placeMatchRadiusMeters
      );
      let historyHeader = overrides.adsbHistoryAuthHeader !== undefined
        ? overrides.adsbHistoryAuthHeader
        : base.adsbHistoryAuthHeader;
      if (typeof historyHeader !== "string") {
        historyHeader = "";
      } else {
        historyHeader = historyHeader.trim();
      }

      return {
        altitudeThresholdFt: Number.isFinite(altitude) && altitude > 0
          ? altitude
          : DEFAULT_ALTITUDE_THRESHOLD_FT,
        speedThresholdKt: Number.isFinite(speed) && speed >= 0
          ? speed
          : DEFAULT_SPEED_THRESHOLD_KT,
        offlineTimeoutSec: Number.isFinite(timeout) && timeout >= 5
          ? Math.max(5, Math.round(timeout))
          : DEFAULT_OFFLINE_TIMEOUT_SEC,
        placeMatchRadiusMeters: Number.isFinite(radius) && radius > 0
          ? radius
          : DEFAULT_PLACE_RADIUS_FALLBACK_METERS,
        notificationsEnabled: overrides.notificationsEnabled !== undefined
          ? !!overrides.notificationsEnabled
          : !!(base && base.notificationsEnabled),
        notifyOnTakeoff: overrides.notifyOnTakeoff !== undefined
          ? !!overrides.notifyOnTakeoff
          : !(base && Object.prototype.hasOwnProperty.call(base, "notifyOnTakeoff")) || base.notifyOnTakeoff !== false,
        notifyOnLanding: overrides.notifyOnLanding !== undefined
          ? !!overrides.notifyOnLanding
          : !(base && Object.prototype.hasOwnProperty.call(base, "notifyOnLanding")) || base.notifyOnLanding !== false,
        adsbHistoryAuthHeader: historyHeader
      };
    }

    function normalizeHex(hex) {
      if (typeof hex !== "string") return "";
      return hex.trim().toLowerCase();
    }

    function dedupeAircraftEntries(list) {
      if (!Array.isArray(list)) {
        return [];
      }

      const map = new Map();

      list.forEach(entry => {
        if (!entry || typeof entry !== "object") {
          return;
        }

        const normalizedHex = normalizeHex(entry.hex);
        if (!normalizedHex) {
          return;
        }

        const candidate = { ...entry, hex: normalizedHex };
        if (typeof candidate.name === "string") {
          candidate.name = candidate.name.trim();
          if (!candidate.name) {
            delete candidate.name;
          }
        }

        map.set(normalizedHex, candidate);
      });

      return Array.from(map.values());
    }

    function getAircraftEntry(hex) {
      const normalized = normalizeHex(hex);
      if (!normalized || !Array.isArray(currentAircraft)) {
        return null;
      }
      return currentAircraft.find(item => item && normalizeHex(item.hex) === normalized) || null;
    }

    function getAircraftDisplayName(hex, fallback = "") {
      const entry = getAircraftEntry(hex);
      if (entry && typeof entry.name === "string" && entry.name.trim()) {
        return entry.name.trim();
      }
      if (fallback && typeof fallback === "string" && fallback.trim()) {
        return fallback.trim();
      }
      if (hex && typeof hex === "string") {
        return hex.trim().toUpperCase();
      }
      return "Unbekanntes Flugzeug";
    }

    function cleanupEventMap() {
      if (activeEventMap) {
        activeEventMap.remove();
        activeEventMap = null;
      }
    }

    function destroyDashboardMap() {
      const frame = document.getElementById("dashboardMapFrame");
      const fallback = document.getElementById("dashboardMapFallback");
      if (frame) {
        frame.src = "about:blank";
        frame.classList.add("hidden");
      }
      if (fallback) {
        fallback.classList.remove("hidden");
        fallback.textContent = "Lade Position...";
      }
      dashboardMapCurrentHex = "";
      dashboardMapCurrentConfigKey = "";
    }

    function destroyDashboardChart() {
      if (dashboardChartInstance) {
        dashboardChartInstance.destroy();
        dashboardChartInstance = null;
      }
    }

    function clearDashboardRefreshTimer() {
      if (dashboardRefreshTimer) {
        clearInterval(dashboardRefreshTimer);
        dashboardRefreshTimer = null;
      }
    }

    function setActiveView(view) {
      if (view !== "events") {
        cancelDebugNotificationTimer();
        activeEventDetail = null;
      }
      if (view !== "dashboard") {
        destroyDashboardMap();
        destroyDashboardChart();
        clearDashboardRefreshTimer();
      }
      activeView = view;
      const buttons = document.querySelectorAll('.nav-item[data-view]');
      const viewTitle = document.getElementById("viewTitle");
      if (viewTitle) {
        viewTitle.textContent = viewTitleMap[view] || "Overview";
      }

      buttons.forEach(button => {
        button.classList.remove(...navActiveButtonClasses, ...navInactiveButtonClasses);
        button.classList.add(...navInactiveButtonClasses);
        button.removeAttribute("aria-current");

        const icon = button.querySelector('.nav-icon');
        if (icon) {
          icon.classList.remove(...navActiveIconClasses, ...navInactiveIconClasses, "nav-active-icon");
          icon.classList.add(...navInactiveIconClasses);
        }

        if (button.dataset.view === view) {
          button.classList.remove(...navInactiveButtonClasses);
          button.classList.add(...navActiveButtonClasses);
          button.setAttribute("aria-current", "page");

          if (icon) {
            icon.classList.remove(...navInactiveIconClasses);
            icon.classList.add(...navActiveIconClasses, "nav-active-icon");
          }
        }
      });

      window.requestAnimationFrame(() => {
        updateLayoutOffsets();
      });
    }

    function updateSettingsSectionVisibility() {
      const sections = document.querySelectorAll('[data-settings-section]');
      sections.forEach(section => {
        if (!section || !section.dataset) return;
        if (section.dataset.settingsSection === activeSettingsSection) {
          section.classList.remove("hidden");
        } else {
          section.classList.add("hidden");
        }
      });

      const tabs = document.querySelectorAll('[data-settings-tab]');
      tabs.forEach(tab => {
        if (!tab || !tab.dataset) return;
        tab.classList.remove(...settingsTabActiveClasses, ...settingsTabInactiveClasses);
        const isActive = tab.dataset.settingsTab === activeSettingsSection;
        if (isActive) {
          tab.classList.add(...settingsTabActiveClasses);
          tab.setAttribute("aria-current", "true");
        } else {
          tab.classList.add(...settingsTabInactiveClasses);
          tab.removeAttribute("aria-current");
        }
      });
    }

    function selectSettingsSection(sectionId) {
      const fallback = settingsSectionOrder[0] || "aircraft";
      const target = settingsSectionOrder.includes(sectionId) ? sectionId : fallback;
      activeSettingsSection = target;
      updateSettingsSectionVisibility();
    }

    async function initializeTracker() {
      void ensureServiceWorkerReady();
      notificationPreferencesReadyPromise = preloadConfigForNotifications();
      startEventStream();

      if (pendingNotificationNavigation && pendingNotificationNavigation.event) {
        const { event: pendingEvent, groupKey: pendingGroup } = pendingNotificationNavigation;
        pendingNotificationNavigation = null;
        const opened = openEventDetailFromNotification(pendingEvent, pendingGroup || "");
        if (opened) {
          return;
        }
      }

      pendingNotificationNavigation = null;

      const container = document.getElementById("content");
      if (container) {
        container.innerHTML = createStatusCard("Lade Daten...");
      }

      const detectedHex = (await fetchLatestHex()) || (await fetchFirstHexFromLogs());

      if (detectedHex) {
        setCurrentHex(detectedHex, { callsign: "" });
      }

      showDashboard();
    }

    async function fetchLatestHex() {
      try {
        const r = await fetch("/latest");
        if (!r.ok) return null;
        const data = await r.json();
        if (data && typeof data.hex === "string" && data.hex.trim()) {
          return data.hex.trim().toLowerCase();
        }
      } catch (err) {
        console.warn("[Init] /latest konnte nicht geladen werden:", err);
      }
      return null;
    }

    async function fetchFirstHexFromLogs() {
      try {
        const r = await fetch("/log");
        if (!r.ok) return null;
        const list = await r.json();
        if (Array.isArray(list) && list.length > 0) {
          const candidate = list.find(entry => entry && entry.hex && entry.count > 0) || list[0];
          if (candidate && candidate.hex) {
            return String(candidate.hex).toLowerCase();
          }
        }
      } catch (err) {
        console.warn("[Init] /log Übersicht konnte nicht geladen werden:", err);
      }
      return null;
    }

    function scheduleEventStreamReconnect() {
      if (eventStreamReconnectTimer) {
        return;
      }
      eventStreamReconnectTimer = setTimeout(() => {
        eventStreamReconnectTimer = null;
        startEventStream();
      }, EVENT_STREAM_RETRY_MS);
    }

    function startEventStream() {
      if (typeof EventSource === "undefined") {
        console.warn("[Events] EventSource wird nicht unterstützt. Live-Benachrichtigungen deaktiviert.");
        return;
      }
      if (eventStreamSource) {
        return;
      }

      try {
        const source = new EventSource("/events/stream");
        eventStreamSource = source;

        source.onopen = () => {
          if (eventStreamReconnectTimer) {
            clearTimeout(eventStreamReconnectTimer);
            eventStreamReconnectTimer = null;
          }
        };

        source.addEventListener("init", event => {
          const payload = parseJSONSafe(event.data) || {};
          if (payload && payload.lastEventId) {
            lastReceivedEventId = String(payload.lastEventId);
          }
        });

        source.addEventListener("event", event => {
          if (event && event.lastEventId) {
            lastReceivedEventId = event.lastEventId;
          }
          const payload = parseJSONSafe(event.data);
          if (payload && payload.event) {
            processIncomingEvent(payload.event);
          }
        });

        source.onerror = err => {
          console.warn("[Events] Verbindung zum Server-Stream verloren:", err);
          try {
            source.close();
          } catch (closeErr) {
            console.warn("[Events] EventSource konnte nicht geschlossen werden:", closeErr);
          }
          eventStreamSource = null;
          scheduleEventStreamReconnect();
        };
      } catch (err) {
        console.warn("[Events] Event Stream konnte nicht gestartet werden:", err);
        eventStreamSource = null;
        scheduleEventStreamReconnect();
      }
    }

    function getEventTypeLabel(event) {
      const type = event && typeof event.type === "string" ? event.type.toLowerCase() : "";
      if (type === "takeoff") return "takeoff";
      if (type === "landing") return "landing";
      return type;
    }

    function getEventVerb(event) {
      const type = getEventTypeLabel(event);
      if (type === "takeoff") return "gestartet";
      if (type === "landing") return "gelandet";
      return "unterwegs";
    }

    function getEventSubject(event) {
      if (!event || typeof event !== "object") {
        return "Unbekanntes Flugzeug";
      }
      const callsign = typeof event.callsign === "string" ? event.callsign.trim() : "";
      if (callsign) {
        return callsign;
      }
      const hex = event.hex ? String(event.hex).trim().toUpperCase() : "";
      if (hex) {
        return hex;
      }
      return "Unbekanntes Flugzeug";
    }

    function getEventPlaceLabel(event) {
      if (!event) {
        return "der letzten bekannten Position";
      }
      return getEventPlaceName(event.place ?? null, event.type);
    }

    function shouldNotifyForEvent(event) {
      if (!notificationPreferences || !notificationPreferences.enabled) {
        return false;
      }
      const type = getEventTypeLabel(event);
      if (!NOTIFICATION_EVENT_TYPES.has(type)) {
        return false;
      }
      if (type === "takeoff" && !notificationPreferences.notifyOnTakeoff) {
        return false;
      }
      if (type === "landing" && !notificationPreferences.notifyOnLanding) {
        return false;
      }
      return true;
    }

    function buildNotificationDetails(event) {
      const subject = getEventSubject(event);
      const verb = getEventVerb(event);
      const place = getEventPlaceLabel(event);
      const locationPart = place === "der letzten bekannten Position"
        ? "an der letzten bekannten Position"
        : `in der Nähe von ${place}`;
      const title = `${subject} ist ${verb} ${locationPart}`;
      const tagId = event && event.id ? String(event.id) : `evt-${Date.now()}`;
      const clonedEvent = cloneEventForNotification(event);

      let eventParam = "";
      if (clonedEvent) {
        try {
          eventParam = encodeURIComponent(JSON.stringify(clonedEvent));
        } catch (err) {
          console.warn("[Notifications] Event konnte nicht serialisiert werden:", err);
          eventParam = "";
        }
      }

      const targetUrl = (() => {
        try {
          const url = new URL(window.location.href);
          url.search = "";
          url.hash = "";
          if (eventParam) {
            const params = new URLSearchParams();
            if (clonedEvent && clonedEvent.id !== undefined && clonedEvent.id !== null) {
              params.set("eventId", String(clonedEvent.id));
            }
            params.set("eventPayload", eventParam);
            url.search = params.toString();
          }
          return url.toString();
        } catch (err) {
          return window.location.origin;
        }
      })();

      const notificationData = {
        url: targetUrl,
        event: clonedEvent,
        groupKey: event && typeof event.groupKey === "string" ? event.groupKey : null,
        eventId: clonedEvent && clonedEvent.id ? String(clonedEvent.id) : null
      };

      if (eventParam) {
        notificationData.eventPayload = eventParam;
      }

      return {
        title,
        options: {
          body: "Jetzt im Heli Tracker ansehen.",
          icon: "/icons/icon-192.png",
          badge: "/icons/icon-192.png",
          tag: `heli-tracker-${tagId}`,
          renotify: true,
          data: notificationData
        }
      };
    }

    async function showNotificationForEvent(event) {
      await ensureNotificationPreferencesReady();
      if (!shouldNotifyForEvent(event)) {
        return;
      }
      const hasPermission = await ensureNotificationPermission();
      if (!hasPermission) {
        return;
      }
      const registration = await ensureServiceWorkerReady();
      if (!registration) {
        return;
      }

      const details = buildNotificationDetails(event);
      try {
        await registration.showNotification(details.title, details.options);
      } catch (err) {
        console.warn("[Notifications] Benachrichtigung konnte nicht angezeigt werden:", err);
      }
    }

    function cloneEventForNotification(rawEvent) {
      if (!rawEvent || typeof rawEvent !== "object") {
        return null;
      }

      const clone = { ...rawEvent };
      if (clone.place && typeof clone.place === "object") {
        clone.place = { ...clone.place };
      }

      return clone;
    }

    function processIncomingEvent(rawEvent) {
      if (!rawEvent || typeof rawEvent !== "object") {
        return;
      }

      const type = getEventTypeLabel(rawEvent);
      if (!NOTIFICATION_EVENT_TYPES.has(type)) {
        return;
      }

      const event = cloneEventForNotification(rawEvent);
      if (!event) {
        return;
      }

      currentEvents = Array.isArray(currentEvents) ? [...currentEvents] : [];
      const existingIndex = currentEvents.findIndex(item => item && item.id === event.id);
      if (existingIndex >= 0) {
        currentEvents[existingIndex] = event;
      } else {
        currentEvents.push(event);
      }

      currentEventGroups = groupEventsByAircraft(currentEvents);

      if (activeView === "events") {
        if (eventDetailReturnState.mode === EVENTS_VIEW_GROUP) {
          renderEventsDetail();
        } else if (eventDetailReturnState.mode === EVENTS_VIEW_DETAIL) {
          renderEventDetail(activeEventDetail, eventDetailReturnState.groupKey || null);
        } else {
          renderEventsOverview();
        }
      } else if (activeView === "dashboard") {
        renderDashboardRecentEvents(currentEvents);
        renderDashboardWeeklyChart(currentEvents);
        updateDashboardFlightMetrics(latestTelemetry, currentEvents);
      }

      const settingsEventsList = document.getElementById("eventsList");
      if (settingsEventsList) {
        renderEventsManagementTable(currentEvents);
      }

      void showNotificationForEvent(event);
    }

    function updateHeaderAircraftLabel() {
      const badge = document.getElementById("headerCallsign");
      if (!badge) {
        return;
      }
      const label = currentCallsign
        ? currentCallsign
        : (currentHex ? currentHex.toUpperCase() : "—");
      badge.textContent = label || "—";
    }

    function setCurrentCallsign(value) {
      currentCallsign = typeof value === "string" ? value.trim() : "";
      updateHeaderAircraftLabel();
    }

    function getTelemetryCallsign(data) {
      if (!data || typeof data !== "object") {
        return "";
      }
      const direct = typeof data.callsign === "string" ? data.callsign.trim() : "";
      if (direct) {
        return direct;
      }
      const fallback = typeof data.flight === "string" ? data.flight.trim() : "";
      return fallback;
    }

    function setCurrentHex(hex, options = {}) {
      const normalized = normalizeHex(hex);
      if (!normalized) {
        return;
      }
      const previousHex = currentHex;
      currentHex = normalized;
      const input = document.getElementById("hexInput");
      if (input) {
        const currentInputValue = normalizeHex(input.value || "");
        if (!hexInputDirty || currentInputValue === currentHex) {
          input.value = currentHex;
          hexInputDirty = false;
        }
      }
      if (options && Object.prototype.hasOwnProperty.call(options, "callsign")) {
        currentCallsign = typeof options.callsign === "string" ? options.callsign.trim() : "";
      } else if (!options || options.keepCallsign !== true) {
        currentCallsign = "";
      }
      updateHeaderAircraftLabel();
      const shouldForceRefresh = options && options.forceRefresh === true;
      if (previousHex !== normalized || shouldForceRefresh) {
        refreshAdsbExchangeFrames({ force: true });
      }
    }

    function setHexStatus(message, type = "") {
      const el = document.getElementById("hexStatus");
      if (!el) return;
      const base = "mt-4 text-sm font-medium tracking-wide";
      let color = "text-slate-500";
      if (type === "success") {
        color = "text-emerald-600";
      } else if (type === "error") {
        color = "text-rose-500";
      }
      el.className = `${base} ${color}`;
      el.textContent = message || "";
    }

    function renderMap(hex = currentHex) {
      cleanupEventMap();
      if (!hex) {
        const container = document.getElementById("content");
        if (container) {
          container.innerHTML = createStatusCard("Bitte eine ICAO Hex eingeben.");
        }
        mapViewCurrentConfigKey = "";
        setActiveView("map");
        return;
      }

      setCurrentHex(hex, { keepCallsign: true });
      setActiveView("map");

      const container = document.getElementById("content");
      if (!container) return;

      container.innerHTML = `
        <section class="view-panel">
          <div class="relative overflow-hidden rounded-[1.5rem] bg-slate-200 shadow-card ring-1 ring-black/5">
            <iframe
              id="mapViewFrame"
              src="about:blank"
              class="h-[calc(100dvh-14rem)] min-h-[24rem] w-full border-0"
              loading="lazy"
            ></iframe>
          </div>
        </section>`;

      updateStandaloneMapFrame({ force: true });
    }

    function updateStandaloneMapFrame(options = {}) {
      const frame = document.getElementById("mapViewFrame");

      if (!frame) {
        if (options.force) {
          mapViewCurrentConfigKey = "";
        }
        return;
      }

      const hex = normalizeHex(currentHex);
      if (!hex) {
        frame.src = "about:blank";
        mapViewCurrentConfigKey = "";
        return;
      }

      const configKey = hex;
      if (!options.force && mapViewCurrentConfigKey === configKey) {
        return;
      }

      try {
        const url = buildAdsbExchangeUrl(hex);
        if (!url) {
          throw new Error("URL leer");
        }
        frame.src = url;
        mapViewCurrentConfigKey = configKey;
      } catch (err) {
        console.warn("[Map] Einzelkartenansicht konnte nicht aktualisiert werden:", err);
        mapViewCurrentConfigKey = "";
      }
    }

    function openEventDetailView(payload, groupKey = "") {
      if (!payload || typeof payload !== "object") {
        console.warn("[Events] Ungültiges Event zum Öffnen.");
        return;
      }

      let resolvedGroupKey = "";
      if (typeof groupKey === "string" && groupKey) {
        resolvedGroupKey = groupKey;
      } else if (typeof activeEventGroupKey === "string" && activeEventGroupKey) {
        resolvedGroupKey = activeEventGroupKey;
      }

      const normalizedGroupKey = typeof resolvedGroupKey === "string" && resolvedGroupKey
        ? resolvedGroupKey
        : null;

      eventDetailReturnState = { mode: EVENTS_VIEW_DETAIL, groupKey: normalizedGroupKey };

      renderEventDetail(payload, normalizedGroupKey);
    }

    function openEventDetailFromNotification(payload, groupKey = "") {
      if (!payload || typeof payload !== "object") {
        console.warn("[Notifications] Benachrichtigungs-Event ungültig.");
        return false;
      }

      openEventDetailView(payload, typeof groupKey === "string" ? groupKey : "");
      return true;
    }

    function openEventFromEncoded(encodedEvent, encodedGroupKey = "") {
      if (typeof encodedEvent !== "string" || !encodedEvent) {
        console.warn("[Events] Kein Event ausgewählt.");
        return;
      }

      try {
        const decoded = decodeURIComponent(encodedEvent);
        const payload = JSON.parse(decoded);

        let groupKey = "";
        if (typeof encodedGroupKey === "string" && encodedGroupKey) {
          try {
            groupKey = decodeURIComponent(encodedGroupKey);
          } catch (err) {
            console.warn("[Events] Gruppenschlüssel konnte nicht dekodiert werden:", err);
          }
        }

        openEventDetailView(payload, groupKey);
      } catch (err) {
        console.error("[Events] Event konnte nicht geöffnet werden:", err);
      }
    }

    function updateEventDebugStatus(message, type = "info") {
      const el = document.getElementById("eventDebugStatus");
      if (!el) {
        return;
      }

      let color = "text-amber-700";
      if (type === "success") {
        color = "text-emerald-600";
      } else if (type === "error") {
        color = "text-rose-600";
      }

      el.className = `mt-1 text-xs font-semibold ${color}`;
      el.textContent = message || "";
    }

    function cancelDebugNotificationTimer() {
      if (debugNotificationTimer) {
        clearTimeout(debugNotificationTimer);
        debugNotificationTimer = null;
      }
    }

    async function scheduleDebugNotificationForEvent(event) {
      if (!notificationDebugMode) {
        updateEventDebugStatus("Debug-Modus ist deaktiviert.", "error");
        return;
      }

      if (!isNotificationSupported()) {
        updateEventDebugStatus("Benachrichtigungen werden nicht unterstützt.", "error");
        return;
      }

      const payload = cloneEventForNotification(event);
      if (!payload) {
        updateEventDebugStatus("Keine Eventdaten verfügbar.", "error");
        return;
      }

      await ensureNotificationPreferencesReady();
      if (!shouldNotifyForEvent(payload)) {
        updateEventDebugStatus("Benachrichtigungen für dieses Event sind deaktiviert.", "error");
        return;
      }

      cancelDebugNotificationTimer();
      updateEventDebugStatus("Debug-Benachrichtigung wird in 5 Sekunden gesendet...", "info");

      debugNotificationTimer = setTimeout(async () => {
        try {
          await showNotificationForEvent(payload);
          updateEventDebugStatus("Debug-Benachrichtigung wurde gesendet.", "success");
        } catch (err) {
          console.warn("[Notifications] Debug-Benachrichtigung fehlgeschlagen:", err);
          updateEventDebugStatus("Debug-Benachrichtigung konnte nicht gesendet werden.", "error");
        } finally {
          debugNotificationTimer = null;
        }
      }, 5000);
    }

    function renderEventDetail(event, groupKey = null) {
      stopSettingsInterval();
      setActiveView("events");
      cancelDebugNotificationTimer();
      cleanupEventMap();

      const target = document.getElementById("content");
      if (!target) return;
      if (target.dataset) {
        if (target.dataset.eventsView === EVENTS_VIEW_OVERVIEW) {
          eventsOverviewScrollTop = target.scrollTop || 0;
        } else if (target.dataset.eventsView === EVENTS_VIEW_GROUP && activeEventGroupKey) {
          eventGroupScrollPositions.set(activeEventGroupKey, target.scrollTop || 0);
        }
        target.dataset.eventsView = EVENTS_VIEW_DETAIL;
      }

      const normalizedGroupKey = typeof groupKey === "string" && groupKey
        ? groupKey
        : (typeof eventDetailReturnState.groupKey === "string" && eventDetailReturnState.groupKey
          ? eventDetailReturnState.groupKey
          : null);

      if (normalizedGroupKey) {
        activeEventGroupKey = normalizedGroupKey;
      }

      eventDetailReturnState = { mode: EVENTS_VIEW_DETAIL, groupKey: normalizedGroupKey };

      const normalizedEvent = cloneEventForNotification(event);
      if (!normalizedEvent) {
        target.innerHTML = `
          <section class="view-panel space-y-6">
            ${createEmptyCard("Event konnte nicht geladen werden.")}
          </section>`;
        scrollViewportToTop(target);
        activeEventDetail = null;
        return;
      }

      event = normalizedEvent;
      activeEventDetail = normalizedEvent;

      const latRaw = event && Object.prototype.hasOwnProperty.call(event, "lat") ? event.lat : null;
      const lonRaw = event && Object.prototype.hasOwnProperty.call(event, "lon") ? event.lon : null;
      const latNum = typeof latRaw === "number" ? latRaw : Number(latRaw);
      const lonNum = typeof lonRaw === "number" ? lonRaw : Number(lonRaw);
      const hasCoords = Number.isFinite(latNum) && Number.isFinite(lonNum);
      const latStr = hasCoords ? latNum.toFixed(6) : "—";
      const lonStr = hasCoords ? lonNum.toFixed(6) : "—";
      const coordinateLabel = hasCoords ? `${latStr}, ${lonStr}` : "Keine Koordinaten verfügbar";
      const fallbackMessage = hasCoords
        ? "Karte konnte nicht geladen werden."
        : "Keine Koordinaten für dieses Event vorhanden.";
      const mapsLink = hasCoords
        ? `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(`${latStr},${lonStr}`)}`
        : null;

      const typeRaw = typeof event?.type === "string" ? event.type : "";
      const typeNormalized = typeRaw.toLowerCase();
      const typeLabel = typeRaw ? typeRaw.charAt(0).toUpperCase() + typeRaw.slice(1) : "Event";
      const callsign = event?.callsign || event?.hex || "—";
      const hexLabel = event?.hex ? String(event.hex).toUpperCase() : String(callsign || "—").toUpperCase();
      const timeLabel = formatDateTime(event?.time);
      const locationLabel = getEventLocationLabel(event);
      const altitudeLabel = formatMetricValue(event?.alt, "ft");
      const speedLabel = formatMetricValue(event?.gs, "kt");

      const showDebugButton = notificationDebugMode && NOTIFICATION_EVENT_TYPES.has(typeNormalized);

      const mapAction = mapsLink
        ? `<a
              href="${mapsLink}"
              target="_blank"
              rel="noopener"
              class="inline-flex items-center gap-2 rounded-2xl bg-brand-purple px-5 py-3 text-sm font-semibold text-white shadow-card transition-all duration-300 hover:scale-[1.02] hover:shadow-lg focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/60"
            >
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-5 w-5">
                <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5H19.5V10.5M19.5 4.5L12 12" />
                <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 12.75V18a2.25 2.25 0 01-2.25 2.25H6.75A2.25 2.25 0 014.5 18V6.75A2.25 2.25 0 016.75 4.5H12" />
              </svg>
              In Google Maps öffnen
            </a>`
        : `<span class="inline-flex items-center gap-2 rounded-2xl bg-slate-200 px-5 py-3 text-sm font-semibold text-slate-500">Keine Koordinaten verfügbar</span>`;

      const debugSection = showDebugButton
        ? `<div class="rounded-3xl border border-amber-200/60 bg-amber-50/60 px-5 py-5 shadow-inner shadow-amber-100/60">
            <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
              <div>
                <h4 class="text-base font-semibold text-amber-800">Debug-Benachrichtigung</h4>
                <p id="eventDebugStatus" class="mt-1 text-xs font-semibold text-amber-700">Sende eine Benachrichtigung 5 Sekunden nach Klick.</p>
              </div>
              <button id="eventDebugTrigger" type="button" class="inline-flex items-center gap-2 rounded-2xl bg-amber-500 px-5 py-3 text-sm font-semibold uppercase tracking-[0.35em] text-white shadow-lg shadow-amber-500/40 transition duration-300 hover:scale-[1.02] hover:bg-amber-500/90 hover:shadow-amber-500/60 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-amber-500/70">
                Verzögert testen
              </button>
            </div>
          </div>`
        : "";

      target.innerHTML = `
        <section class="view-panel space-y-6">
          <div class="flex flex-wrap items-center justify-between gap-4">
            <div class="flex items-center gap-3">
              <button
                type="button"
                onclick="handleEventDetailBack()"
                class="inline-flex h-11 w-11 items-center justify-center rounded-2xl border border-brand-purple/20 bg-white px-3 text-brand-purple shadow-sm transition-transform duration-300 hover:scale-105 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/60"
                aria-label="Zurück zu den Events"
              >
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-5 w-5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                </svg>
              </button>
              <div class="space-y-1">
                <p class="text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple/70">${escapeHtml(typeLabel)}</p>
                <h2 class="text-2xl font-semibold text-brand-ink">${escapeHtml(callsign)}</h2>
                <p class="text-sm text-slate-500">${escapeHtml(timeLabel)}</p>
              </div>
            </div>
            <span class="rounded-full bg-brand-purple/10 px-4 py-2 text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple">HEX ${escapeHtml(hexLabel)}</span>
          </div>
          <div class="overflow-hidden rounded-[1.5rem] shadow-card ring-1 ring-black/5">
            <div class="relative h-[60vh] min-h-[24rem] bg-slate-200">
              <div id="eventMap" class="absolute inset-0 h-full w-full ${hasCoords ? "" : "hidden"}"></div>
              <div id="eventMapFallback" class="absolute inset-0 flex items-center justify-center px-6 text-center text-sm font-medium text-slate-600 ${hasCoords ? "hidden" : ""}">${escapeHtml(fallbackMessage)}</div>
            </div>
            <div class="flex flex-wrap items-center justify-between gap-3 bg-white/90 px-5 py-4 text-sm text-brand-ink backdrop-blur">
              <div>
                <p class="text-[0.65rem] uppercase tracking-[0.35em] text-slate-400">Event Position</p>
                <p class="mt-1 text-lg font-semibold text-brand-ink">${escapeHtml(coordinateLabel)}</p>
              </div>
              ${mapAction}
            </div>
          </div>
          <div class="grid gap-3 sm:grid-cols-3">
            ${createInfoCard("Ort", locationLabel)}
            ${createInfoCard("Speed", speedLabel)}
            ${createInfoCard("Altitude", altitudeLabel)}
          </div>
          ${debugSection}
        </section>`;
      scrollViewportToTop(target);

      if (showDebugButton) {
        const debugButton = document.getElementById("eventDebugTrigger");
        if (debugButton) {
          debugButton.addEventListener("click", () => {
            void scheduleDebugNotificationForEvent(event);
          });
        }
      }

      if (!hasCoords) {
        return;
      }

      const mapContainer = document.getElementById("eventMap");
      const fallbackEl = document.getElementById("eventMapFallback");

      if (typeof L !== "undefined" && mapContainer) {
        activeEventMap = L.map(mapContainer, { zoomControl: false });
        L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
          maxZoom: 19,
          attribution: 'Imagery © <a href="https://www.esri.com/">Esri</a>, Earthstar Geographics'
        }).addTo(activeEventMap);
        L.marker([latNum, lonNum]).addTo(activeEventMap);
        activeEventMap.setView([latNum, lonNum], 16);
        if (fallbackEl) {
          fallbackEl.classList.add("hidden");
        }
        setTimeout(() => {
          if (activeEventMap) {
            activeEventMap.invalidateSize();
          }
        }, 0);
      } else {
        if (fallbackEl) {
          fallbackEl.classList.remove("hidden");
          fallbackEl.textContent = "Karte konnte nicht geladen werden.";
        }
      }
    }

    function createInfoCard(label, value) {
      return `<div class="rounded-2xl border border-brand-purple/10 bg-white px-4 py-3 shadow-card sm:px-5 sm:py-4">
        <p class="text-[0.75rem] uppercase tracking-[0.35em] text-brand-purple/70 sm:text-[0.65rem]">${escapeHtml(label)}</p>
        <p class="mt-1 text-lg font-semibold text-brand-ink">${escapeHtml(value)}</p>
      </div>`;
    }

    function stopSettingsInterval() {
      if (settingsInterval) {
        clearInterval(settingsInterval);
        settingsInterval = null;
      }
    }

    function showDashboard() {
      stopSettingsInterval();
      setActiveView("dashboard");
      cleanupEventMap();
      cancelDebugNotificationTimer();
      clearDashboardRefreshTimer();
      destroyDashboardMap();
      destroyDashboardChart();

      const container = document.getElementById("content");
      if (!container) return;

      container.innerHTML = `
        <section class="view-panel mx-auto flex h-full w-full max-w-6xl flex-col gap-4 pb-6">
          <div class="grid flex-1 gap-4 lg:grid-cols-[1.5fr_1fr]">
            <article class="flex flex-col rounded-3xl bg-white/95 px-6 py-6 shadow-card ring-1 ring-white/60 backdrop-blur">
              <div class="flex items-center justify-between gap-4">
                <div>
                  <p class="text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple/70">Live Map</p>
                  <h2 class="text-2xl font-semibold text-brand-ink">Live Map – Current Position</h2>
                </div>
              </div>
              <div class="relative mt-4 h-64 w-full overflow-hidden rounded-2xl border border-slate-200/60 bg-white shadow-inner">
                <iframe
                  id="dashboardMapFrame"
                  src="about:blank"
                  class="hidden h-full w-full border-0"
                  loading="lazy"
                ></iframe>
                <div id="dashboardMapFallback" class="absolute inset-0 flex items-center justify-center px-4 text-center text-sm font-medium text-slate-600">
                  Bitte ein Flugzeug auswählen.
                </div>
              </div>
            </article>
            <article class="flex flex-col justify-between rounded-3xl bg-white/95 px-6 py-6 shadow-card ring-1 ring-white/60 backdrop-blur">
              <div>
                <p class="text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple/70">Weather</p>
                <h2 class="text-2xl font-semibold text-brand-ink">Lokale Bedingungen</h2>
              </div>
              <div class="mt-4 flex flex-1 flex-col justify-between gap-6 sm:flex-row sm:items-center sm:gap-6">
                <div class="space-y-4">
                  <div>
                    <p class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Temperatur</p>
                    <p id="weatherTemperature" class="mt-2 text-2xl font-semibold text-brand-ink">—</p>
                  </div>
                  <div>
                    <p class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Wind</p>
                    <p id="weatherWind" class="mt-2 text-lg font-semibold text-brand-ink">—</p>
                  </div>
                  <div>
                    <p class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Sicht</p>
                    <p id="weatherVisibility" class="mt-2 text-lg font-semibold text-brand-ink">—</p>
                  </div>
                </div>
                <div class="flex h-20 w-20 items-center justify-center rounded-full bg-brand-purple/10 text-4xl">
                  <span id="weatherIcon" aria-hidden="true">☀️</span>
                </div>
              </div>
              <p id="weatherMessage" class="mt-4 text-xs text-slate-500">Warte auf Positionsdaten...</p>
            </article>
          </div>
          <div class="grid gap-4 lg:grid-cols-[1.5fr_1fr]">
            <article class="flex flex-col rounded-3xl bg-white/95 px-6 py-6 shadow-card ring-1 ring-white/60 backdrop-blur">
              <div class="flex items-center justify-between gap-4">
                <div>
                  <p class="text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple/70">Flight Data</p>
                  <h2 class="text-2xl font-semibold text-brand-ink">Aktuelle Telemetrie</h2>
                </div>
              </div>
              <div id="telemetryMetrics" class="mt-4 grid gap-4 sm:grid-cols-3">
                <div class="rounded-2xl border border-brand-purple/10 bg-white px-5 py-5 shadow-card">
                  <p class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Speed</p>
                  <p id="flightSpeedValue" class="mt-3 text-2xl font-semibold text-brand-ink">—</p>
                  <p class="text-xs font-medium uppercase tracking-[0.25em] text-slate-400">kt</p>
                </div>
                <div class="rounded-2xl border border-brand-purple/10 bg-white px-5 py-5 shadow-card">
                  <p class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Altitude</p>
                  <p id="flightAltitudeValue" class="mt-3 text-2xl font-semibold text-brand-ink">—</p>
                  <p class="text-xs font-medium uppercase tracking-[0.25em] text-slate-400">ft</p>
                </div>
                <div class="rounded-2xl border border-brand-purple/10 bg-white px-5 py-5 shadow-card">
                  <p class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Distance</p>
                  <p id="flightDistanceValue" class="mt-3 text-2xl font-semibold text-brand-ink">—</p>
                  <p class="text-xs font-medium uppercase tracking-[0.25em] text-slate-400">km</p>
                </div>
              </div>
              <div
                id="deviceLocationNotice"
                class="mt-4 flex flex-col gap-3 rounded-2xl border border-dashed border-brand-purple/30 bg-brand-purple/5 px-5 py-4 text-sm text-brand-ink"
              >
                <div>
                  <p class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Device Location</p>
                  <p id="deviceLocationMessage" class="mt-2 text-sm font-medium text-brand-ink">
                    Standortzugriff erforderlich, um die Distanz zum Flugzeug zu berechnen.
                  </p>
                </div>
                <button
                  id="deviceLocationButton"
                  type="button"
                  class="inline-flex items-center justify-center self-start rounded-xl bg-brand-purple px-4 py-2 text-[0.75rem] font-semibold uppercase tracking-[0.3em] text-white shadow transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/40 disabled:cursor-not-allowed disabled:opacity-60"
                >
                  Standort aktivieren
                </button>
              </div>
              <div id="telemetryGroundNotice" class="mt-6 hidden rounded-2xl border border-amber-200/60 bg-amber-100/80 px-5 py-4 text-center text-base font-semibold text-amber-700 shadow-inner">
                On Ground
              </div>
              <p id="flightDataTimestamp" class="mt-4 text-xs text-slate-500">Aktualisiert: —</p>
            </article>
            <article class="flex flex-col rounded-3xl bg-white/95 px-6 py-6 shadow-card ring-1 ring-white/60 backdrop-blur">
              <div class="flex items-center justify-between gap-4">
                <div>
                  <p class="text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple/70">Statistics</p>
                  <h2 class="text-2xl font-semibold text-brand-ink">Flüge der letzten 7 Tage</h2>
                </div>
                <button
                  type="button"
                  class="inline-flex items-center gap-2 rounded-full border border-brand-purple/20 px-3 py-1 text-[0.65rem] font-semibold uppercase tracking-[0.35em] text-brand-purple transition hover:bg-brand-purple/10 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/40"
                  onclick="void loadDashboardData()"
                >
                  Aktualisieren
                </button>
              </div>
              <div class="relative mt-4 flex-1 rounded-2xl border border-slate-200/60 bg-white/80 p-4 shadow-inner">
                <canvas id="dashboardFlightsChart" class="h-full min-h-[14rem] w-full"></canvas>
                <div id="dashboardChartEmpty" class="pointer-events-none absolute inset-0 flex items-center justify-center rounded-2xl text-sm font-medium text-slate-500">
                  Keine Event-Daten verfügbar.
                </div>
              </div>
            </article>
          </div>
          <article class="flex min-h-0 flex-col rounded-3xl bg-white/95 px-6 py-6 shadow-card ring-1 ring-white/60 backdrop-blur">
            <div class="flex items-center justify-between gap-4">
              <div>
                <p class="text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple/70">Letzte Events</p>
                <h2 class="text-2xl font-semibold text-brand-ink">Takeoff &amp; Landing Historie</h2>
              </div>
            </div>
            <div id="dashboardEventsList" class="mt-4 flex-1 space-y-3 overflow-y-auto pr-1"></div>
            <p id="dashboardEventsEmpty" class="mt-4 text-sm text-slate-500">Noch keine Takeoff- oder Landing-Events erkannt.</p>
          </article>
        </section>`;

      setupDeviceLocationUI();
      initializeDeviceLocationTracking();

      requestAnimationFrame(() => {
        void loadDashboardData();
      });

      if (typeof window !== "undefined") {
        dashboardRefreshTimer = setInterval(() => {
          void loadDashboardData({ silent: true });
        }, DASHBOARD_REFRESH_INTERVAL_MS);
      }
    }

    async function loadDashboardData(options = {}) {
      const { silent = false } = options;
      const fallback = document.getElementById("dashboardMapFallback");
      const timestampEl = document.getElementById("flightDataTimestamp");

      if (!silent && fallback) {
        fallback.classList.remove("hidden");
        fallback.textContent = "Lade Position...";
      }

      try {
        const [latestResponse, eventsResponse] = await Promise.all([
          fetch("/latest")
            .then(res => (res.ok ? res.json() : null))
            .catch(err => {
              console.warn("[Dashboard] /latest konnte nicht geladen werden:", err);
              return null;
            }),
          fetchEventsList()
            .then(list => (Array.isArray(list) ? list : []))
            .catch(err => {
              console.warn("[Dashboard] /events konnte nicht geladen werden:", err);
              return Array.isArray(currentEvents) ? currentEvents : [];
            })
        ]);

        const latest = latestResponse && typeof latestResponse === "object"
          ? latestResponse
          : null;

        if (Array.isArray(eventsResponse)) {
          currentEvents = eventsResponse;
          currentEventGroups = groupEventsByAircraft(currentEvents);
        }

        latestTelemetry = latest;

        const telemetryCallsign = getTelemetryCallsign(latest);
        if (latest && latest.hex) {
          if (telemetryCallsign) {
            setCurrentHex(latest.hex, { callsign: telemetryCallsign });
          } else {
            setCurrentHex(latest.hex, { keepCallsign: true });
          }
        } else if (telemetryCallsign) {
          setCurrentCallsign(telemetryCallsign);
        }

        updateFlightStatusBadgeFromLatest(latest);
        updateDashboardFlightMetrics(latest, currentEvents);
        updateDashboardMapWithLatest(latest);
        await updateDashboardWeather(latest);
        renderDashboardWeeklyChart(currentEvents);
        renderDashboardRecentEvents(currentEvents);

        if (timestampEl) {
          timestampEl.textContent = `Aktualisiert: ${latest && latest.time ? formatDateTime(latest.time) : "—"}`;
        }
      } catch (err) {
        console.error("[Dashboard] Daten konnten nicht geladen werden:", err);
        updateFlightStatusBadge(null);
        if (fallback) {
          fallback.classList.remove("hidden");
          fallback.textContent = "Daten konnten nicht geladen werden.";
        }
      }
    }

    function updateDashboardMapWithLatest(latest, options = {}) {
      const frame = document.getElementById("dashboardMapFrame");
      const fallback = document.getElementById("dashboardMapFallback");

      if (!frame) {
        return;
      }

      const latestHex = latest && typeof latest.hex === "string" ? latest.hex : null;
      const normalizedHex = normalizeHex(latestHex || currentHex);

      if (!normalizedHex) {
        if (fallback) {
          fallback.classList.remove("hidden");
          fallback.textContent = "Bitte ein Flugzeug auswählen.";
        }
        frame.classList.add("hidden");
        dashboardMapCurrentHex = "";
        dashboardMapCurrentConfigKey = "";
        return;
      }

      if (fallback) {
        fallback.classList.add("hidden");
        fallback.textContent = "";
      }

      frame.classList.remove("hidden");

      const configKey = normalizedHex;

      if (!options.force && dashboardMapCurrentConfigKey === configKey) {
        return;
      }

      try {
        const url = buildAdsbExchangeUrl(normalizedHex);
        if (!url) {
          throw new Error("Ungültige URL");
        }
        frame.src = url;
        dashboardMapCurrentHex = normalizedHex;
        dashboardMapCurrentConfigKey = configKey;
      } catch (err) {
        console.warn("[Dashboard] Kartenansicht konnte nicht aktualisiert werden:", err);
        if (fallback) {
          fallback.classList.remove("hidden");
          fallback.textContent = "Karte konnte nicht geladen werden.";
        }
        frame.classList.add("hidden");
        dashboardMapCurrentConfigKey = "";
      }
    }

    function updateDashboardFlightMetrics(latest, events) {
      const speedEl = document.getElementById("flightSpeedValue");
      const altitudeEl = document.getElementById("flightAltitudeValue");
      const distanceEl = document.getElementById("flightDistanceValue");

      const speed = latest && latest.gs !== undefined ? Number(latest.gs) : null;
      const altitude = latest && latest.alt !== undefined ? Number(latest.alt) : null;
      const distance = calculateDistanceFromEvents(latest, events);

      if (speedEl) {
        speedEl.textContent = Number.isFinite(speed) ? Math.round(speed).toString() : "—";
      }
      if (altitudeEl) {
        altitudeEl.textContent = Number.isFinite(altitude) ? Math.round(altitude).toString() : "—";
      }
      if (distanceEl) {
        distanceEl.textContent = Number.isFinite(distance) ? distance.toFixed(1) : "—";
      }
    }

    function calculateDistanceFromEvents(latest, events) {
      if (!latest || typeof latest !== "object") {
        return null;
      }

      const lat = Number(latest.lat);
      const lon = Number(latest.lon);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
        return null;
      }

      const deviceCoords = getValidDeviceLocation();
      if (deviceCoords) {
        const distanceToDevice = haversineDistanceKm(deviceCoords.lat, deviceCoords.lon, lat, lon);
        if (Number.isFinite(distanceToDevice)) {
          return distanceToDevice;
        }
      }

      const latestHex = typeof latest.hex === "string" ? normalizeHex(latest.hex) : "";
      const selectedHex = normalizeHex(currentHex);
      const selectedCallsign = typeof currentCallsign === "string" ? currentCallsign.trim().toLowerCase() : "";

      const relevantEvents = Array.isArray(events)
        ? events
            .filter(item => {
              if (!item || typeof item !== "object") {
                return false;
              }
              const type = typeof item.type === "string" ? item.type.toLowerCase() : "";
              if (type !== "takeoff" && type !== "landing") {
                return false;
              }
              const evLat = Number(item.lat);
              const evLon = Number(item.lon);
              if (!Number.isFinite(evLat) || !Number.isFinite(evLon)) {
                return false;
              }
              const eventHex = typeof item.hex === "string" ? normalizeHex(item.hex) : "";
              const eventCallsign = typeof item.callsign === "string" ? item.callsign.trim().toLowerCase() : "";
              if (latestHex && eventHex) {
                return eventHex === latestHex;
              }
              if (selectedHex && eventHex) {
                return eventHex === selectedHex;
              }
              if (!selectedHex && selectedCallsign && eventCallsign) {
                return eventCallsign === selectedCallsign;
              }
              return !selectedHex && !selectedCallsign;
            })
            .sort((a, b) => {
              const timeA = new Date(a.time).getTime();
              const timeB = new Date(b.time).getTime();
              const validA = Number.isFinite(timeA);
              const validB = Number.isFinite(timeB);
              if (validA && validB) {
                return timeB - timeA;
              }
              if (validA && !validB) {
                return -1;
              }
              if (!validA && validB) {
                return 1;
              }
              return 0;
            })
        : [];

      if (relevantEvents.length === 0) {
        return null;
      }

      const latestEvent = relevantEvents[0];
      const eventLat = Number(latestEvent.lat);
      const eventLon = Number(latestEvent.lon);

      if (!Number.isFinite(eventLat) || !Number.isFinite(eventLon)) {
        return null;
      }

      const distance = haversineDistanceKm(lat, lon, eventLat, eventLon);
      return Number.isFinite(distance) ? distance : null;
    }

    function haversineDistanceKm(lat1, lon1, lat2, lon2) {
      const toRad = deg => (deg * Math.PI) / 180;
      const R = 6371;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat / 2) ** 2
        + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function renderDashboardWeeklyChart(events) {
      const canvas = document.getElementById("dashboardFlightsChart");
      const emptyState = document.getElementById("dashboardChartEmpty");

      if (!canvas) {
        return;
      }

      if (dashboardChartInstance) {
        dashboardChartInstance.destroy();
        dashboardChartInstance = null;
      }

      if (typeof Chart === "undefined") {
        if (emptyState) {
          emptyState.classList.remove("hidden");
          emptyState.textContent = "Diagramm konnte nicht geladen werden.";
        }
        return;
      }

      const start = new Date();
      start.setHours(0, 0, 0, 0);
      start.setDate(start.getDate() - 6);

      const dayKeys = [];
      for (let i = 0; i < 7; i += 1) {
        const day = new Date(start);
        day.setDate(start.getDate() + i);
        dayKeys.push(day.toISOString().slice(0, 10));
      }

      const counts = new Map(dayKeys.map(key => [key, 0]));

      if (Array.isArray(events)) {
        events.forEach(event => {
          if (!event || typeof event !== "object" || !event.time) {
            return;
          }
          const type = typeof event.type === "string" ? event.type.toLowerCase() : "";
          if (type !== "takeoff" && type !== "landing") {
            return;
          }
          const date = new Date(event.time);
          if (Number.isNaN(date.getTime())) {
            return;
          }
          const key = date.toISOString().slice(0, 10);
          if (counts.has(key)) {
            if (type === "takeoff") {
              counts.set(key, (counts.get(key) || 0) + 1);
            }
          }
        });
      }

      const labels = dayKeys.map(key => formatDateLabel(key));
      const data = dayKeys.map(key => counts.get(key) || 0);

      const hasData = data.some(value => value > 0);
      if (emptyState) {
        emptyState.classList.toggle("hidden", hasData);
      }

      const context = canvas.getContext("2d");
      dashboardChartInstance = new Chart(context, {
        type: "bar",
        data: {
          labels,
          datasets: [
            {
              label: "Flüge",
              data,
              backgroundColor: "rgba(111, 93, 247, 0.45)",
              hoverBackgroundColor: "rgba(111, 93, 247, 0.65)",
              borderRadius: 12,
              maxBarThickness: 42
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              grid: { display: false },
              ticks: { font: { family: "Inter" } }
            },
            y: {
              beginAtZero: true,
              grid: { color: "rgba(148, 163, 184, 0.25)" },
              ticks: {
                precision: 0,
                stepSize: 1,
                font: { family: "Inter" }
              }
            }
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              backgroundColor: "rgba(28, 28, 30, 0.9)",
              displayColors: false,
              titleFont: { family: "Inter", weight: "600" },
              bodyFont: { family: "Inter", weight: "500" },
              callbacks: {
                label: context => `Flüge: ${context.parsed.y}`
              }
            }
          }
        }
      });
    }

    function renderDashboardRecentEvents(events) {
      const list = document.getElementById("dashboardEventsList");
      const empty = document.getElementById("dashboardEventsEmpty");

      if (!list) {
        return;
      }

      const targetHex = normalizeHex(currentHex);
      const targetCallsign = typeof currentCallsign === "string" ? currentCallsign.trim().toLowerCase() : "";

      if (!targetHex && !targetCallsign) {
        list.innerHTML = "";
        if (empty) {
          empty.textContent = "Bitte ein Flugzeug auswählen, um Events zu sehen.";
          empty.classList.remove("hidden");
        }
        return;
      }

      const matchesCurrentAircraft = event => {
        if (!event || typeof event !== "object") {
          return false;
        }
        const eventHex = normalizeHex(event.hex);
        const eventCallsign = typeof event.callsign === "string" ? event.callsign.trim().toLowerCase() : "";

        if (targetHex && eventHex) {
          return eventHex === targetHex;
        }
        if (targetCallsign && eventCallsign) {
          return eventCallsign === targetCallsign;
        }
        return false;
      };

      const normalized = Array.isArray(events)
        ? events
            .filter(event => {
              if (!event || typeof event !== "object") {
                return false;
              }
              const type = typeof event.type === "string" ? event.type.toLowerCase() : "";
              if (type !== "takeoff" && type !== "landing") {
                return false;
              }
              return matchesCurrentAircraft(event);
            })
            .sort((a, b) => {
              const timeA = new Date(a.time).getTime();
              const timeB = new Date(b.time).getTime();
              const validA = Number.isFinite(timeA);
              const validB = Number.isFinite(timeB);
              if (validA && validB) {
                return timeB - timeA;
              }
              if (validA && !validB) {
                return -1;
              }
              if (!validA && validB) {
                return 1;
              }
              return 0;
            })
        : [];

      const items = normalized.slice(0, 6);

      if (items.length === 0) {
        list.innerHTML = "";
        if (empty) {
          empty.textContent = "Keine Events für dieses Flugzeug gefunden.";
          empty.classList.remove("hidden");
        }
        return;
      }

      list.innerHTML = items.map(renderDashboardEventCard).join("");
      if (empty) {
        empty.classList.add("hidden");
      }
    }

    function renderDashboardEventCard(event) {
      const type = typeof event?.type === "string" ? event.type.toLowerCase() : "";
      const isLanding = type === "landing";
      const iconClasses = isLanding
        ? "bg-emerald-100 text-emerald-600"
        : "bg-rose-100 text-rose-600";
      const iconSvg = isLanding
        ? '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-5 w-5"><path stroke-linecap="round" stroke-linejoin="round" d="M3 3v5.25a2.25 2.25 0 002.25 2.25h7.5A2.25 2.25 0 0015 8.25V3m0 0l-3-3m3 3l3-3M3 21h18" /></svg>'
        : '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-5 w-5"><path stroke-linecap="round" stroke-linejoin="round" d="M3 21v-5.25A2.25 2.25 0 015.25 13.5h7.5A2.25 2.25 0 0115 15.75V21m0 0l-3 3m3-3l3 3M3 3h18" /></svg>';
      const callsign = event && typeof event.callsign === "string" && event.callsign.trim()
        ? event.callsign.trim()
        : (event && event.hex ? String(event.hex).trim().toUpperCase() : "Unbekannt");
      const timeLabel = event && event.time ? formatDateTime(event.time) : "—";
      const locationLabel = formatDashboardLocation(event);
      const coordinateLabel = formatDashboardCoordinates(event);
      const statusLabel = isLanding ? "Landing" : "Takeoff";

      return `<article class="flex flex-col gap-4 rounded-2xl border border-slate-200/70 bg-white/90 px-4 py-4 shadow-card transition hover:border-brand-purple/40 hover:shadow-lg md:flex-row md:items-center md:justify-between">
        <div class="flex items-center gap-3">
          <span class="inline-flex h-10 w-10 items-center justify-center rounded-2xl ${iconClasses}">
            ${iconSvg}
          </span>
          <div>
            <p class="text-sm font-semibold text-brand-ink">${escapeHtml(callsign)}</p>
            <p class="text-xs uppercase tracking-[0.3em] text-slate-400">${escapeHtml(statusLabel)}</p>
            <p class="text-xs text-slate-500">${escapeHtml(timeLabel)}</p>
          </div>
        </div>
        <div class="flex flex-col gap-3 text-sm text-slate-600 sm:flex-row sm:items-center sm:gap-6">
          <div class="flex items-center gap-2">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-5 w-5 text-brand-purple/70">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 10.5a3 3 0 11-6 0 3 3 0 016 0z" />
              <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 10.5c0 7.5-7.5 12-7.5 12s-7.5-4.5-7.5-12a7.5 7.5 0 1115 0z" />
            </svg>
            <span class="font-medium">${escapeHtml(locationLabel)}</span>
          </div>
          <div class="flex items-center gap-2">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-5 w-5 text-brand-purple/70">
              <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v12m6-6H6" />
            </svg>
            <span>${escapeHtml(coordinateLabel)}</span>
          </div>
        </div>
      </article>`;
    }

    function formatDashboardLocation(event) {
      if (!event || typeof event !== "object") {
        return "Unbekannter Ort";
      }

      const place = event.place && typeof event.place === "object" ? event.place : null;
      const localityFromPlace = getPlaceDisplayName(place);
      if (localityFromPlace) {
        return localityFromPlace;
      }

      if (typeof event.location === "string" && event.location.trim()) {
        const locality = extractLocalityLabel(event.location);
        return locality || "Unbekannter Ort";
      }

      return "Unbekannter Ort";
    }

    function formatDashboardCoordinates(event) {
      if (!event || typeof event !== "object") {
        return "Keine Koordinaten";
      }

      const lat = formatCoordinate(event.lat);
      const lon = formatCoordinate(event.lon);
      if (lat === "—" || lon === "—") {
        return "Keine Koordinaten";
      }
      return `${lat}, ${lon}`;
    }

    function updateFlightStatusBadgeFromLatest(latest) {
      const status = deriveFlightStatus(latest);
      updateFlightStatusBadge(status);
      return status;
    }

    function deriveFlightStatus(latest) {
      if (!latest || typeof latest !== "object") {
        return null;
      }

      const thresholds = getEffectiveThresholds();
      const altitude = Number(latest.alt);
      const speed = Number(latest.gs);

      if ((Number.isFinite(altitude) && altitude > thresholds.altitude)
        || (Number.isFinite(speed) && speed > thresholds.speed)) {
        return "air";
      }

      if (Number.isFinite(altitude) || Number.isFinite(speed)) {
        return "ground";
      }

      return null;
    }

    function getEffectiveThresholds() {
      const cfg = currentConfigCache || {};
      const altitude = Number(cfg.altitudeThresholdFt);
      const speed = Number(cfg.speedThresholdKt);
      return {
        altitude: Number.isFinite(altitude) ? altitude : DEFAULT_ALTITUDE_THRESHOLD_FT,
        speed: Number.isFinite(speed) ? speed : DEFAULT_SPEED_THRESHOLD_KT
      };
    }

    function updateFlightStatusBadge(status) {
      const badge = document.getElementById("flightStatusBadge");
      if (!badge) {
        return;
      }

      const base = "inline-flex items-center rounded-full border px-4 py-1 text-[0.65rem] font-semibold uppercase tracking-[0.35em]";
      let className = `${base} border-white/30 bg-white/10 text-white/70`;
      let label = "—";

      if (status === "air") {
        className = `${base} border-emerald-200/60 bg-emerald-500/40 text-white`;
        label = "Luft";
      } else if (status === "ground") {
        className = `${base} border-amber-200/60 bg-amber-400/50 text-white`;
        label = "Boden";
      }

      badge.className = className;
      badge.textContent = label;
      updateTelemetryCardState(status);
    }

    function updateTelemetryCardState(status) {
      const metrics = document.getElementById("telemetryMetrics");
      const groundNotice = document.getElementById("telemetryGroundNotice");
      if (!metrics || !groundNotice) {
        return;
      }

      if (status === "ground") {
        metrics.classList.add("hidden");
        groundNotice.classList.remove("hidden");
      } else {
        metrics.classList.remove("hidden");
        groundNotice.classList.add("hidden");
      }
    }

    async function updateDashboardWeather(latest) {
      const statusEl = document.getElementById("weatherMessage");
      if (!statusEl) {
        return;
      }

      const lat = Number(latest && latest.lat);
      const lon = Number(latest && latest.lon);

      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
        applyWeatherToCard(null);
        statusEl.textContent = "Keine Positionsdaten verfügbar.";
        return;
      }

      const now = Date.now();
      if (
        lastWeatherData
        && lastWeatherFetch
        && lastWeatherFetch.lat === lat
        && lastWeatherFetch.lon === lon
        && now - lastWeatherFetch.timestamp < WEATHER_REFRESH_INTERVAL_MS
      ) {
        applyWeatherToCard(lastWeatherData);
        statusEl.textContent = lastWeatherData.updatedAt
          ? `Aktualisiert: ${formatDateTime(lastWeatherData.updatedAt)}`
          : "Aktualisiert";
        return;
      }

      statusEl.textContent = "Lade Wetterdaten...";

      try {
        const params = new URLSearchParams({
          latitude: lat.toString(),
          longitude: lon.toString(),
          current: "temperature_2m,wind_speed_10m,visibility,weather_code",
          timezone: "auto"
        });
        const response = await fetch(`https://api.open-meteo.com/v1/forecast?${params.toString()}`);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const payload = await response.json();
        const current = payload && payload.current;
        if (!current) {
          throw new Error("Keine Wetterdaten verfügbar");
        }

        const weather = {
          temperature: Number(current.temperature_2m),
          wind: Number(current.wind_speed_10m),
          visibility: Number(current.visibility),
          code: current.weather_code,
          updatedAt: current.time
        };

        lastWeatherFetch = { lat, lon, timestamp: now };
        lastWeatherData = weather;

        applyWeatherToCard(weather);
        statusEl.textContent = weather.updatedAt
          ? `Aktualisiert: ${formatDateTime(weather.updatedAt)}`
          : "Aktualisiert";
      } catch (err) {
        console.warn("[Dashboard] Wetter konnte nicht geladen werden:", err);
        applyWeatherToCard(null);
        statusEl.textContent = "Wetterdaten konnten nicht geladen werden.";
      }
    }

    function applyWeatherToCard(weather) {
      const tempEl = document.getElementById("weatherTemperature");
      const windEl = document.getElementById("weatherWind");
      const visibilityEl = document.getElementById("weatherVisibility");
      const iconEl = document.getElementById("weatherIcon");

      if (!tempEl || !windEl || !visibilityEl || !iconEl) {
        return;
      }

      if (!weather) {
        tempEl.textContent = "—";
        windEl.textContent = "—";
        visibilityEl.textContent = "—";
        iconEl.textContent = "☀️";
        iconEl.title = "Keine Daten";
        return;
      }

      const visibilityKm = Number.isFinite(weather.visibility)
        ? Math.max(weather.visibility / 1000, 0)
        : null;

      tempEl.textContent = Number.isFinite(weather.temperature)
        ? `${weather.temperature.toFixed(1)} °C`
        : "—";
      windEl.textContent = Number.isFinite(weather.wind)
        ? `${Math.round(weather.wind)} km/h`
        : "—";
      visibilityEl.textContent = Number.isFinite(visibilityKm)
        ? `${visibilityKm.toFixed(1)} km`
        : "—";

      const icon = interpretWeatherCode(weather.code);
      iconEl.textContent = icon.icon;
      iconEl.title = icon.label;
    }

    function interpretWeatherCode(code) {
      const value = Number(code);
      if (!Number.isFinite(value)) {
        return { icon: "☀️", label: "Keine Daten" };
      }

      const rainCodes = new Set([51, 53, 55, 56, 57, 61, 63, 65, 66, 67, 80, 81, 82, 95, 96, 99]);
      const snowCodes = new Set([71, 73, 75, 77, 85, 86]);

      if (value === 0) {
        return { icon: "☀️", label: "Klar" };
      }
      if ([1, 2, 3, 45, 48].includes(value)) {
        return { icon: "⛅", label: "Bewölkt" };
      }
      if (rainCodes.has(value)) {
        return { icon: "🌧️", label: "Regen" };
      }
      if (snowCodes.has(value)) {
        return { icon: "❄️", label: "Schnee" };
      }

      return { icon: "⛅", label: "Wetter" };
    }

    function showADSB() {
      stopSettingsInterval();
      renderMap(currentHex);
    }


    function createEmptyCard(message) {
      return `<div class="rounded-2xl bg-white/90 p-6 text-center text-sm font-medium text-slate-500 shadow-card ring-1 ring-black/5 backdrop-blur">${escapeHtml(message)}</div>`;
    }

    async function showEvents() {
      stopSettingsInterval();
      setActiveView("events");
      cleanupEventMap();
      cancelDebugNotificationTimer();
      activeEventDetail = null;
      eventDetailReturnState = { mode: EVENTS_VIEW_OVERVIEW, groupKey: null };

      const container = document.getElementById("content");
      if (!container) return;

      container.innerHTML = createStatusCard("Lade Events...");

      try {
        const [eventsData, aircraftData] = await Promise.all([
          fetchEventsList(),
          fetchAircraftList().catch(err => {
            console.warn("[Events] Flugzeugliste konnte nicht geladen werden:", err);
            return currentAircraft;
          })
        ]);

        const events = Array.isArray(eventsData)
          ? eventsData.filter(item => {
              const type = typeof item?.type === "string" ? item.type.toLowerCase() : "";
              return type === "takeoff" || type === "landing";
            })
          : [];

        currentEvents = events;
        if (Array.isArray(aircraftData)) {
          currentAircraft = dedupeAircraftEntries(aircraftData);
        }

        currentEventGroups = groupEventsByAircraft(events);
        activeEventGroupKey = null;
        eventDetailReturnState = { mode: EVENTS_VIEW_OVERVIEW, groupKey: null };
        renderEventsOverview();
      } catch (err) {
        console.error("[Events] Liste konnte nicht geladen werden:", err);
        const message = err && err.message ? err.message : String(err);
        container.innerHTML = `
          <section class="view-panel mx-auto w-full max-w-4xl space-y-6 p-4">
            ${createEmptyCard(`Fehler beim Laden der Events (${escapeHtml(message)})`)}
          </section>`;
      }
    }

    function groupEventsByAircraft(events) {
      if (!Array.isArray(events) || events.length === 0) {
        return [];
      }

      const map = new Map();

      events.forEach((event, index) => {
        if (!event || typeof event !== "object") {
          return;
        }

        const typeRaw = typeof event.type === "string" ? event.type.toLowerCase() : "";
        if (typeRaw !== "takeoff" && typeRaw !== "landing") {
          return;
        }

        const hex = event.hex ? normalizeHex(event.hex) : "";
        const callsign = typeof event.callsign === "string" ? event.callsign.trim() : "";
        const id = event.id !== undefined && event.id !== null ? String(event.id) : "";

        let key = "";
        if (hex) {
          key = `hex:${hex}`;
        } else if (callsign) {
          key = `callsign:${callsign.toLowerCase()}`;
        } else if (id) {
          key = `id:${id}`;
        } else {
          key = `idx:${index}`;
        }

        if (!map.has(key)) {
          map.set(key, { key, hex, callsign, events: [] });
        }

        map.get(key).events.push(event);
      });

      return Array.from(map.values());
    }

    function renderEventsOverview() {
      const container = document.getElementById("content");
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.eventsView === EVENTS_VIEW_OVERVIEW) {
          eventsOverviewScrollTop = container.scrollTop || 0;
        } else if (container.dataset.eventsView === EVENTS_VIEW_GROUP && activeEventGroupKey) {
          eventGroupScrollPositions.set(activeEventGroupKey, container.scrollTop || 0);
        }
        container.dataset.eventsView = EVENTS_VIEW_OVERVIEW;
      }
      eventDetailReturnState = { mode: EVENTS_VIEW_OVERVIEW, groupKey: null };

      if (!Array.isArray(currentEventGroups) || currentEventGroups.length === 0) {
        container.innerHTML = `
          <section class="view-panel mx-auto w-full max-w-5xl space-y-6">
            <div class="flex flex-col gap-2">
              <p class="text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple/70">Events</p>
              <h2 class="text-3xl font-semibold text-brand-ink">Aktuelle Flugbewegungen</h2>
              <p class="text-sm text-slate-500">Noch wurden keine Takeoff- oder Landing-Events erkannt.</p>
            </div>
            ${createEmptyCard("Noch keine Events erkannt")}
          </section>`;
        requestAnimationFrame(() => {
          container.scrollTop = eventsOverviewScrollTop || 0;
        });
        return;
      }

      const sortedGroups = [...currentEventGroups].sort((a, b) => {
        const latestA = getLatestEventTime(a.events);
        const latestB = getLatestEventTime(b.events);
        if (latestA && latestB) return latestB - latestA;
        if (latestA) return -1;
        if (latestB) return 1;
        return 0;
      });

      const cards = sortedGroups.map(group => {
        const events = getSortedEventsForGroup(group.events);
        const latest = events[0] || null;
        const takeoffCount = events.filter(event => typeof event?.type === "string" && event.type.toLowerCase() === "takeoff").length;
        const landingCount = events.filter(event => typeof event?.type === "string" && event.type.toLowerCase() === "landing").length;
        const displayName = getAircraftDisplayName(group.hex, group.callsign || group.hex || "");
        const hexLabel = group.hex ? group.hex.toUpperCase() : "—";
        const callsignLabel = group.callsign && group.callsign.toLowerCase() !== group.hex
          ? group.callsign
          : "";
        const timeLabel = latest ? formatDateTime(latest.time) : "—";
        const safeKey = encodeURIComponent(group.key);

        return `<article class="group rounded-3xl border border-slate-100/80 bg-white/80 p-4 shadow-inner shadow-white/50 transition duration-300 hover:border-brand-purple/40 hover:shadow-brand-purple/10">
            <div class="flex flex-col gap-4">
              <div class="flex flex-col gap-2 sm:flex-row sm:items-start sm:justify-between">
                <div class="space-y-1">
                  <h3 class="text-xl font-semibold text-brand-ink">${escapeHtml(displayName)}</h3>
                  <p class="text-xs font-semibold uppercase tracking-[0.3em] text-slate-400">HEX ${escapeHtml(hexLabel)}</p>
                  ${callsignLabel ? `<p class="text-xs text-slate-500">Callsign: ${escapeHtml(callsignLabel)}</p>` : ""}
                </div>
                <div class="flex flex-col items-start sm:items-end">
                  <span class="text-xs font-semibold uppercase tracking-[0.3em] text-slate-400">Letztes Event</span>
                  <span class="text-sm font-semibold text-brand-ink">${escapeHtml(timeLabel)}</span>
                </div>
              </div>
              <div class="flex flex-wrap gap-2 text-xs text-slate-500">
                <span class="rounded-2xl bg-brand-frost px-3 py-1 font-semibold text-slate-600">Takeoffs: <span class="text-brand-ink">${takeoffCount}</span></span>
                <span class="rounded-2xl bg-brand-frost px-3 py-1 font-semibold text-slate-600">Landings: <span class="text-brand-ink">${landingCount}</span></span>
              </div>
              <div class="flex justify-end">
                <button type="button" class="inline-flex items-center gap-2 rounded-2xl bg-brand-purple px-5 py-3 text-sm font-semibold uppercase tracking-[0.35em] text-white shadow-card transition duration-300 hover:scale-[1.02] hover:shadow-lg focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/50" onclick="openEventsDetail('${safeKey}')">
                  Events ansehen
                  <span aria-hidden="true">→</span>
                </button>
              </div>
            </div>
          </article>`;
      }).join("");

      container.innerHTML = `
        <section class="view-panel mx-auto w-full max-w-6xl space-y-6 pb-8">
          <div class="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
            <div>
              <p class="text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple/70">Events</p>
              <h2 class="text-3xl font-semibold text-brand-ink">Flugzeuge & Bewegungen</h2>
              <p class="text-sm text-slate-500">Wähle ein Flugzeug, um alle zugehörigen Events einzusehen.</p>
            </div>
          </div>
          <div class="grid gap-4 sm:grid-cols-2">${cards}</div>
        </section>`;
      requestAnimationFrame(() => {
        container.scrollTop = eventsOverviewScrollTop || 0;
      });
    }

    function getSortedEventsForGroup(events) {
      if (!Array.isArray(events)) {
        return [];
      }
      return [...events].sort((a, b) => {
        const timeA = Date.parse(a && a.time ? a.time : 0);
        const timeB = Date.parse(b && b.time ? b.time : 0);
        const invalidA = Number.isNaN(timeA);
        const invalidB = Number.isNaN(timeB);
        if (invalidA && invalidB) return 0;
        if (invalidA) return 1;
        if (invalidB) return -1;
        return timeB - timeA;
      });
    }

    function getLatestEventTime(events) {
      const sorted = getSortedEventsForGroup(events);
      if (sorted.length === 0) {
        return null;
      }
      const timestamp = Date.parse(sorted[0].time || 0);
      return Number.isNaN(timestamp) ? null : timestamp;
    }

    function openEventsDetail(encodedKey) {
      let key = "";
      try {
        key = decodeURIComponent(encodedKey || "");
      } catch (err) {
        console.warn("[Events] Ungültiger Schlüssel:", err);
        return;
      }
      if (!key) return;

      const container = document.getElementById("content");
      if (container && container.dataset) {
        if (container.dataset.eventsView === EVENTS_VIEW_OVERVIEW) {
          eventsOverviewScrollTop = container.scrollTop || 0;
        } else if (container.dataset.eventsView === EVENTS_VIEW_GROUP && activeEventGroupKey) {
          eventGroupScrollPositions.set(activeEventGroupKey, container.scrollTop || 0);
        }
      }

      activeEventGroupKey = key;
      eventDetailReturnState = { mode: EVENTS_VIEW_GROUP, groupKey: key };
      renderEventsDetail();
    }

    function returnToEventsOverview() {
      const container = document.getElementById("content");
      if (container && activeEventGroupKey) {
        eventGroupScrollPositions.set(activeEventGroupKey, container.scrollTop || 0);
      }
      activeEventGroupKey = null;
      eventDetailReturnState = { mode: EVENTS_VIEW_OVERVIEW, groupKey: null };
      renderEventsOverview();
    }

    function renderEventsDetail() {
      const container = document.getElementById("content");
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.eventsView === EVENTS_VIEW_OVERVIEW) {
          eventsOverviewScrollTop = container.scrollTop || 0;
        } else if (container.dataset.eventsView === EVENTS_VIEW_GROUP && activeEventGroupKey) {
          eventGroupScrollPositions.set(activeEventGroupKey, container.scrollTop || 0);
        }
        container.dataset.eventsView = EVENTS_VIEW_GROUP;
      }

      const group = Array.isArray(currentEventGroups)
        ? currentEventGroups.find(entry => entry && entry.key === activeEventGroupKey)
        : null;

      if (!group) {
        container.innerHTML = `
          <section class="view-panel mx-auto w-full max-w-4xl space-y-6 p-4">
            ${createEmptyCard("Flugzeug nicht gefunden")}
          </section>`;
        scrollViewportToTop(container);
        return;
      }

      eventDetailReturnState = { mode: EVENTS_VIEW_GROUP, groupKey: group.key };

      const events = getSortedEventsForGroup(group.events);
      const displayName = getAircraftDisplayName(group.hex, group.callsign || group.hex || "");
      const hexLabel = group.hex ? group.hex.toUpperCase() : "—";
      const latest = events[0] || null;
      const takeoffCount = events.filter(event => typeof event?.type === "string" && event.type.toLowerCase() === "takeoff").length;
      const landingCount = events.filter(event => typeof event?.type === "string" && event.type.toLowerCase() === "landing").length;
      const latestTime = latest ? formatDateTime(latest.time) : "—";
      const cards = events.length > 0
        ? events.map(event => buildEventCardHtml(event, group.key)).join("")
        : createEmptyCard("Keine Events für dieses Flugzeug.");

      container.innerHTML = `
        <section class="view-panel mx-auto w-full max-w-5xl space-y-6 pb-10">
          <div class="flex flex-col gap-4">
            <div class="flex items-center justify-between gap-4">
              <div class="flex items-center gap-3">
                <button type="button" onclick="returnToEventsOverview()" class="inline-flex h-11 w-11 items-center justify-center rounded-2xl border border-brand-purple/20 bg-white text-brand-purple shadow-sm transition-transform duration-300 hover:scale-105 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/60" aria-label="Zurück zur Übersicht">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-5 w-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                  </svg>
                </button>
                <div>
                  <p class="text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple/70">Events</p>
                  <h2 class="text-3xl font-semibold text-brand-ink">${escapeHtml(displayName)}</h2>
                  <p class="text-sm text-slate-500">HEX ${escapeHtml(hexLabel)}</p>
                </div>
              </div>
              <div class="text-right">
                <p class="text-xs font-semibold uppercase tracking-[0.3em] text-slate-400">Letztes Event</p>
                <p class="text-sm font-semibold text-brand-ink">${escapeHtml(latestTime)}</p>
              </div>
            </div>
            <div class="flex flex-wrap gap-2 text-xs text-slate-500">
              <span class="rounded-2xl bg-brand-frost px-3 py-1 font-semibold text-slate-600">Takeoffs: <span class="text-brand-ink">${takeoffCount}</span></span>
              <span class="rounded-2xl bg-brand-frost px-3 py-1 font-semibold text-slate-600">Landings: <span class="text-brand-ink">${landingCount}</span></span>
            </div>
          </div>
          <div class="space-y-4">${cards}</div>
        </section>`;

      const storedScroll = eventGroupScrollPositions.get(group.key);
      requestAnimationFrame(() => {
        container.scrollTop = typeof storedScroll === "number" ? storedScroll : 0;
      });
    }

    function handleEventDetailBack() {
      cancelDebugNotificationTimer();
      activeEventDetail = null;
      const targetKey = typeof eventDetailReturnState?.groupKey === "string" && eventDetailReturnState.groupKey
        ? eventDetailReturnState.groupKey
        : null;
      const canReturnToGroup = !!targetKey
        && eventDetailReturnState
        && (eventDetailReturnState.mode === EVENTS_VIEW_DETAIL || eventDetailReturnState.mode === EVENTS_VIEW_GROUP);

      if (canReturnToGroup && Array.isArray(currentEventGroups)) {
        const exists = currentEventGroups.some(entry => entry && entry.key === targetKey);
        if (exists) {
          activeEventGroupKey = targetKey;
          renderEventsDetail();
          return;
        }
      }

      showEvents();
    }

    function buildEventCardHtml(event, groupKey = "") {
      if (!event) return "";

      const typeRaw = typeof event.type === "string" ? event.type : "";
      const type = typeRaw.toLowerCase();
      const isLanding = type === "landing";
      const typeLabel = typeRaw ? typeRaw.toUpperCase() : "EVENT";

      const callsign = escapeHtml(event.callsign || event.hex || "—");
      const altitude = escapeHtml(formatMetricValue(event.alt, "ft"));
      const speed = escapeHtml(formatMetricValue(event.gs, "kt"));
      const time = escapeHtml(formatDateTime(event.time));

      const latNum = Number(event.lat);
      const lonNum = Number(event.lon);
      const hasCoords = Number.isFinite(latNum) && Number.isFinite(lonNum);
      const latFixed = hasCoords ? latNum.toFixed(6) : null;
      const lonFixed = hasCoords ? lonNum.toFixed(6) : null;
      const positionLabel = hasCoords
        ? `${latFixed}°, ${lonFixed}°`
        : `${event.lat ?? "—"}, ${event.lon ?? "—"}`;
      const safePositionLabel = escapeHtml(positionLabel);

      const place = formatEventPlace(event.place, type);

      const eventPayload = {
        time: event.time ?? null,
        type: typeRaw || null,
        hex: event.hex ?? null,
        callsign: event.callsign ?? null,
        lat: hasCoords ? Number(latNum.toFixed(6)) : null,
        lon: hasCoords ? Number(lonNum.toFixed(6)) : null,
        alt: event.alt ?? null,
        gs: event.gs ?? null,
        place: event.place ?? null
      };
      const encodedEvent = encodeURIComponent(JSON.stringify(eventPayload));
      const encodedGroupKey = groupKey ? encodeURIComponent(groupKey) : "";
      const openArgs = encodedGroupKey
        ? `'${encodedEvent}', '${encodedGroupKey}'`
        : `'${encodedEvent}'`;

      const iconBackground = isLanding
        ? "bg-emerald-500 text-white shadow-[0_10px_20px_rgba(16,185,129,0.35)]"
        : "bg-brand-red text-white shadow-[0_10px_20px_rgba(217,48,48,0.35)]";
      const iconSvg = isLanding
        ? '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5" class="h-5 w-5"><path stroke-linecap="round" stroke-linejoin="round" d="M12 21l4-4h-3V5h-2v12H8l4 4z" /><path stroke-linecap="round" stroke-linejoin="round" d="M5 4.5h14" /></svg>'
        : '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5" class="h-5 w-5"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3l-4 4h3v10h2V7h3l-4-4z" /><path stroke-linecap="round" stroke-linejoin="round" d="M5 19.5h14" /></svg>';

      const buttonDisabled = !hasCoords;
      const buttonAttributes = buttonDisabled
        ? 'type="button" disabled'
        : `type="button" onclick="openEventFromEncoded(${openArgs})"`;

      const buttonClasses = buttonDisabled
        ? "inline-flex items-center justify-between gap-2 rounded-2xl bg-slate-200 px-4 py-2 text-sm font-semibold text-slate-400"
        : "inline-flex items-center justify-between gap-2 rounded-2xl bg-brand-purple px-4 py-2 text-sm font-semibold text-white shadow-card transition-all duration-300 hover:scale-[1.02] hover:shadow-lg focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/50";

      return `
        <article class="group flex h-full flex-col gap-4 rounded-2xl bg-white p-4 shadow-card ring-1 ring-black/5 transition-all duration-300 ease-out hover:-translate-y-1 hover:shadow-[0_25px_45px_rgba(111,93,247,0.2)]">
          <div class="flex items-start justify-between gap-3">
            <div class="flex items-start gap-3">
              <span class="flex h-11 w-11 items-center justify-center rounded-xl text-white transition-transform duration-300 group-hover:scale-110 ${iconBackground}">
                ${iconSvg}
              </span>
              <div class="space-y-1">
                <p class="text-xs font-semibold uppercase tracking-[0.3em] text-slate-400">${escapeHtml(typeLabel)}</p>
                <h3 class="text-xl font-semibold text-brand-ink">${callsign}</h3>
                <p class="text-xs text-slate-500">${place}</p>
              </div>
            </div>
            <span class="rounded-full bg-sky-100 px-3 py-1 text-[0.65rem] font-semibold uppercase tracking-[0.35em] text-sky-600">${time}</span>
          </div>
          <div class="grid gap-2 rounded-2xl bg-brand-frost/70 p-3 text-sm text-slate-500">
            <div class="flex items-center justify-between">
              <span class="text-xs uppercase tracking-[0.3em] text-slate-400">Altitude</span>
              <span class="font-semibold text-brand-ink">${altitude}</span>
            </div>
            <div class="flex items-center justify-between">
              <span class="text-xs uppercase tracking-[0.3em] text-slate-400">Speed</span>
              <span class="font-semibold text-brand-ink">${speed}</span>
            </div>
            <div class="flex items-center justify-between">
              <span class="text-xs uppercase tracking-[0.3em] text-slate-400">Position</span>
              <span class="truncate pl-3 text-right font-semibold text-brand-ink">${safePositionLabel}</span>
            </div>
          </div>
          <div class="flex items-center justify-between">
            <p class="text-xs uppercase tracking-[0.3em] text-slate-400">Mehr Details</p>
            <button ${buttonAttributes} class="${buttonClasses} ${buttonDisabled ? "cursor-not-allowed" : ""}">
              <span>Eventdetails anzeigen</span>
              <span aria-hidden="true">→</span>
            </button>
          </div>
        </article>`;
    }

    function getFallbackLocationLabel(eventType) {
      const normalized = typeof eventType === "string" ? eventType.toLowerCase() : "";
      if (normalized === "landing") {
        return "Außenlandung";
      }
      if (normalized === "takeoff") {
        return "Außenstart";
      }
      return "Unbekannter Ort";
    }

    function getPlaceSource(place) {
      if (!place || typeof place !== "object") {
        return "";
      }
      const source = typeof place.source === "string" ? place.source.trim().toLowerCase() : "";
      return source || "";
    }

    function extractLocalityLabel(value) {
      if (typeof value !== "string") {
        return "";
      }
      const trimmed = value.trim();
      if (!trimmed) {
        return "";
      }
      const parts = trimmed.split(",").map(part => part.trim()).filter(Boolean);
      return parts.length > 0 ? parts[0] : trimmed;
    }

    function getPlaceDisplayName(place) {
      if (!place) {
        return "";
      }

      if (typeof place === "string") {
        return extractLocalityLabel(place);
      }

      if (typeof place !== "object") {
        return "";
      }

      const settlementKeys = [
        "city",
        "town",
        "village",
        "municipality",
        "locality",
        "hamlet",
        "suburb",
        "neighbourhood"
      ];

      for (const key of settlementKeys) {
        const value = typeof place[key] === "string" ? place[key].trim() : "";
        if (value) {
          return value;
        }
      }

      const displayName = typeof place.displayName === "string" ? place.displayName.trim() : "";
      if (displayName) {
        return extractLocalityLabel(displayName);
      }

      const name = typeof place.name === "string" ? place.name.trim() : "";
      if (name) {
        return extractLocalityLabel(name);
      }

      const state = typeof place.state === "string" ? place.state.trim() : "";
      if (state) {
        return state;
      }

      const country = typeof place.country === "string" ? place.country.trim() : "";
      if (country) {
        return country;
      }

      const type = typeof place.type === "string" ? place.type.trim() : "";
      if (type && type.toLowerCase() !== "external" && type.toLowerCase() !== "unknown") {
        return type;
      }

      return "";
    }

    function isFallbackPlace(place) {
      if (!place) {
        return true;
      }

      if (typeof place === "string") {
        return false;
      }

      if (typeof place !== "object") {
        return true;
      }

      const source = getPlaceSource(place);
      if (source) {
        return source !== "user";
      }

      const type = typeof place.type === "string" ? place.type.trim().toLowerCase() : "";
      return type === "external" || !type;
    }

    function getEventPlaceDescription(place, eventType) {
      const fallbackLabel = getFallbackLocationLabel(eventType);
      const displayName = getPlaceDisplayName(place);

      if (!displayName) {
        return fallbackLabel;
      }

      if (isFallbackPlace(place)) {
        return `${fallbackLabel} in der Nähe von ${displayName}`;
      }

      return displayName;
    }

    function getEventPlaceName(place, eventType) {
      const displayName = getPlaceDisplayName(place);
      if (displayName) {
        return displayName;
      }
      return "der letzten bekannten Position";
    }

    function formatEventPlace(place, eventType) {
      const description = getEventPlaceDescription(place, eventType);
      return escapeHtml(description);
    }

    function getEventLocationLabel(event) {
      if (!event) {
        return getFallbackLocationLabel();
      }

      return getEventPlaceDescription(event.place ?? null, event.type);
    }

    function getLogOverviewCacheForSource(source = activeLogSource) {
      const key = source === LOG_SOURCE_HISTORY ? LOG_SOURCE_HISTORY : LOG_SOURCE_LIVE;
      const cached = logOverviewCache[key];
      return Array.isArray(cached) ? cached : [];
    }

    function updateCachedLogOverviewForSource(source, list) {
      const key = source === LOG_SOURCE_HISTORY ? LOG_SOURCE_HISTORY : LOG_SOURCE_LIVE;
      logOverviewCache[key] = Array.isArray(list) ? list : [];
      if (key === activeLogSource) {
        cachedLogOverview = getLogOverviewCacheForSource(key);
      }
    }

    function updateLogSourceToggle() {
      const buttons = document.querySelectorAll('[data-log-source]');
      buttons.forEach(button => {
        if (!button) {
          return;
        }
        const source = button.getAttribute('data-log-source');
        button.classList.remove(...logSourceActiveClasses, ...logSourceInactiveClasses);
        const targetClasses = source === activeLogSource ? logSourceActiveClasses : logSourceInactiveClasses;
        button.classList.add(...targetClasses);
      });
    }

    function switchLogSource(source) {
      const normalized = source === LOG_SOURCE_HISTORY ? LOG_SOURCE_HISTORY : LOG_SOURCE_LIVE;
      if (normalized === activeLogSource && !activeLogHex) {
        renderLogOverview(getLogOverviewCacheForSource(normalized));
        return;
      }

      activeLogSource = normalized;
      activeLogHex = null;
      updateLogSourceToggle();
      void loadLogOverview(normalized);
    }

    function findHistoryOverviewEntry(hex) {
      const normalized = normalizeHex(hex);
      if (!normalized) {
        return null;
      }
      const historyCache = getLogOverviewCacheForSource(LOG_SOURCE_HISTORY);
      return historyCache.find(entry => entry && normalizeHex(entry.hex) === normalized) || null;
    }

    function createLogTableRows(entries) {
      if (!Array.isArray(entries) || entries.length === 0) {
        return "";
      }

      return entries.map(entry => {
        const time = escapeHtml(formatDateTime(entry.time));
        const callsign = escapeHtml(entry.callsign || entry.hex || "—");
        const altitude = escapeHtml(formatMetricValue(entry.alt, "ft"));
        const speed = escapeHtml(formatMetricValue(entry.gs, "kt"));

        const latNum = Number(entry.lat);
        const lonNum = Number(entry.lon);
        const hasCoords = Number.isFinite(latNum) && Number.isFinite(lonNum);
        const position = hasCoords
          ? `${latNum.toFixed(4)}°, ${lonNum.toFixed(4)}°`
          : `${entry.lat ?? "—"}, ${entry.lon ?? "—"}`;
        const safePosition = escapeHtml(position);

        return `
          <tr class="divide-x divide-slate-100/80">
            <td class="whitespace-nowrap px-4 py-3 text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">${time}</td>
            <td class="px-4 py-3">
              <div class="text-sm font-semibold text-slate-900">${callsign}</div>
              <div class="text-xs uppercase tracking-[0.3em] text-slate-400">${escapeHtml(entry.hex || "")}</div>
            </td>
            <td class="px-4 py-3 text-sm font-medium text-slate-700">${altitude}</td>
            <td class="px-4 py-3 text-sm font-medium text-slate-700">${speed}</td>
            <td class="px-4 py-3 text-sm text-slate-600">
              <div class="font-medium text-slate-700">${safePosition}</div>
              <div class="text-xs text-slate-400">Lat • Lon</div>
            </td>
          </tr>`;
      }).join("");
    }

    function getSettingsLogsContainer() {
      return document.getElementById("settingsLogsContainer");
    }

    function renderLogsMessage(message) {
      const container = getSettingsLogsContainer();
      if (!container) return;
      container.innerHTML = `<div class="rounded-3xl border border-slate-100/70 bg-white/90 px-6 py-5 text-sm font-medium text-slate-600 shadow-card">${escapeHtml(message)}</div>`;
    }

    async function loadLogOverview(source = activeLogSource) {
      const resolvedSource = source === LOG_SOURCE_HISTORY ? LOG_SOURCE_HISTORY : LOG_SOURCE_LIVE;
      activeLogSource = resolvedSource;
      activeLogHex = null;
      const container = getSettingsLogsContainer();
      if (!container) {
        return;
      }

      updateLogSourceToggle();
      const loadingLabel = resolvedSource === LOG_SOURCE_HISTORY ? "Lade Historie..." : "Lade Logs...";
      renderLogsMessage(loadingLabel);

      try {
        const endpoint = resolvedSource === LOG_SOURCE_HISTORY ? "/history-log" : "/log";
        const response = await fetch(endpoint);
        if (response.status === 404) {
          updateCachedLogOverviewForSource(resolvedSource, []);
          cachedLogOverview = getLogOverviewCacheForSource(resolvedSource);
          renderLogOverview(cachedLogOverview);
          return;
        }
        if (!response.ok) {
          throw new Error(`Serverantwort ${response.status}`);
        }

        const list = await response.json();
        const normalized = Array.isArray(list) ? list : [];
        updateCachedLogOverviewForSource(resolvedSource, normalized);
        cachedLogOverview = getLogOverviewCacheForSource(resolvedSource);
        renderLogOverview(cachedLogOverview);
      } catch (err) {
        console.error("[Logs] Übersicht konnte nicht geladen werden:", err);
        const message = err && err.message ? err.message : String(err);
        container.innerHTML = `
          <div class="space-y-4">
            ${createEmptyCard(`${resolvedSource === LOG_SOURCE_HISTORY ? "Fehler beim Laden der Historie" : "Fehler beim Laden der Logs"} (${escapeHtml(message)})`)}
            <div class="flex justify-center">
              <button type="button" class="inline-flex items-center gap-2 rounded-2xl bg-sky-500 px-5 py-3 text-sm font-semibold text-white shadow-card transition duration-300 hover:scale-[1.02] hover:shadow-lg focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-400" onclick="loadLogOverview('${resolvedSource}')">Erneut versuchen</button>
            </div>
          </div>`;
      }
    }

    function renderLogOverview(list) {
      const container = getSettingsLogsContainer();
      if (!container) return;

      const isHistory = activeLogSource === LOG_SOURCE_HISTORY;

      if (!Array.isArray(list) || list.length === 0) {
        container.innerHTML = createEmptyCard(isHistory ? "Keine Historie vorhanden" : "Keine Logs vorhanden");
        return;
      }

      if (isHistory) {
        const cards = list.map(entry => {
          if (!entry) return "";
          const hex = entry.hex ? String(entry.hex).toLowerCase() : "";
          const hexLabel = hex ? hex.toUpperCase() : "—";
          const name = entry.name ? String(entry.name) : "";
          const title = name ? name : `HEX ${hexLabel}`;
          const totalEntries = Number(entry.totalEntries) || 0;
          const totalDays = Number(entry.totalDays) || 0;
          const countLabel = totalEntries === 1 ? "1 Eintrag" : `${totalEntries} Einträge`;
          const daysLabel = totalDays === 1 ? "1 Tag" : `${totalDays} Tage`;
          const lastTimestamp = entry.lastTimestamp ? escapeHtml(formatDateTime(entry.lastTimestamp)) : "—";

          let dayBadges = "";
          if (Array.isArray(entry.days) && entry.days.length > 0) {
            dayBadges = entry.days.slice(0, 6).map(day => {
              if (!day) return "";
              const dateLabel = formatDateLabel(day.date);
              const records = Number(day.recordCount) || 0;
              const badgeLabel = `${dateLabel} • ${records}`;
              return `<span class="rounded-full bg-brand-purple/10 px-3 py-1 text-[0.65rem] font-semibold uppercase tracking-[0.3em] text-brand-purple/90">${escapeHtml(badgeLabel)}</span>`;
            }).join("");
          }

          const extraCount = Array.isArray(entry.days) && entry.days.length > 6 ? entry.days.length - 6 : 0;
          const extraBadge = extraCount > 0
            ? `<span class="rounded-full bg-slate-200 px-3 py-1 text-[0.65rem] font-semibold uppercase tracking-[0.3em] text-slate-500">+${extraCount}</span>`
            : "";

          const buttonDisabled = !hex;
          const buttonAttributes = buttonDisabled
            ? 'type="button" disabled'
            : `type="button" onclick="openHistoryDetail('${escapeHtml(hex)}')"`;
          const buttonClasses = buttonDisabled
            ? "inline-flex items-center gap-2 rounded-2xl bg-slate-200 px-4 py-2 text-sm font-semibold text-slate-400"
            : "inline-flex items-center gap-2 rounded-2xl bg-brand-purple px-4 py-2 text-sm font-semibold text-white shadow-card transition-all duration-300 hover:scale-[1.02] hover:shadow-lg focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/50";

          return `
            <article class="group flex flex-col gap-4 rounded-2xl bg-white p-4 shadow-card ring-1 ring-black/5 transition-all duration-300 ease-out hover:-translate-y-1 hover:shadow-[0_25px_45px_rgba(111,93,247,0.2)]">
              <div class="flex flex-wrap items-start justify-between gap-3">
                <div class="space-y-2">
                  <h3 class="text-xl font-semibold text-brand-ink">${escapeHtml(title)}</h3>
                  <p class="text-xs uppercase tracking-[0.3em] text-slate-400">HEX ${escapeHtml(hexLabel)}</p>
                  <p class="text-sm text-slate-500">${escapeHtml(countLabel)} • ${escapeHtml(daysLabel)}</p>
                  <p class="text-xs text-slate-400">Letzte Aktualisierung: ${lastTimestamp}</p>
                </div>
                <span class="rounded-full bg-brand-purple/10 px-3 py-1 text-[0.65rem] font-semibold uppercase tracking-[0.35em] text-brand-purple">14-Tage Historie</span>
              </div>
              <div class="flex flex-wrap items-center gap-2 text-xs uppercase tracking-[0.3em] text-slate-500">
                ${dayBadges || `<span class="rounded-full bg-slate-100 px-3 py-1 text-[0.65rem] font-semibold text-slate-400">Keine Tagesdateien</span>`}
                ${extraBadge}
              </div>
              <div class="flex items-center justify-between">
                <span class="text-xs uppercase tracking-[0.3em] text-slate-400">Historie</span>
                <button ${buttonAttributes} class="${buttonClasses} ${buttonDisabled ? "cursor-not-allowed" : ""}">
                  <span>Details ansehen</span>
                  <span aria-hidden="true">→</span>
                </button>
              </div>
            </article>`;
        }).join("");

        container.innerHTML = cards;
        return;
      }

      const cards = list.map(entry => {
        if (!entry) return "";
        const hex = entry.hex ? String(entry.hex).toLowerCase() : "";
        const hexLabel = hex ? hex.toUpperCase() : "—";
        const last = entry.last && typeof entry.last === "object" ? entry.last : {};
        const callsign = escapeHtml(last.callsign || "—");
        const time = escapeHtml(formatDateTime(last.time));
        const altitude = escapeHtml(formatMetricValue(last.alt, "ft"));
        const speed = escapeHtml(formatMetricValue(last.gs, "kt"));
        const count = Number(entry.count) || 0;
        const countLabel = count === 1 ? "1 Eintrag" : `${count} Einträge`;

        const buttonDisabled = !hex;
        const buttonAttributes = buttonDisabled
          ? 'type="button" disabled'
          : `type="button" onclick="openLogDetail('${escapeHtml(hex)}')"`;
        const buttonClasses = buttonDisabled
          ? "inline-flex items-center gap-2 rounded-2xl bg-slate-200 px-4 py-2 text-sm font-semibold text-slate-400"
          : "inline-flex items-center gap-2 rounded-2xl bg-brand-purple px-4 py-2 text-sm font-semibold text-white shadow-card transition-all duration-300 hover:scale-[1.02] hover:shadow-lg focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/50";

        return `
          <article class="group flex flex-col gap-4 rounded-2xl bg-white p-4 shadow-card ring-1 ring-black/5 transition-all duration-300 ease-out hover:-translate-y-1 hover:shadow-[0_25px_45px_rgba(111,93,247,0.2)]">
            <div class="flex flex-wrap items-start justify-between gap-3">
              <div class="space-y-2">
                <h3 class="text-xl font-semibold text-brand-ink">${callsign}</h3>
                <p class="text-xs uppercase tracking-[0.3em] text-slate-400">HEX ${escapeHtml(hexLabel)}</p>
                <p class="text-sm text-slate-500">Alt: ${altitude} • Speed: ${speed}</p>
                <p class="text-xs text-slate-400">${escapeHtml(countLabel)}</p>
              </div>
              <span class="rounded-full bg-sky-100 px-3 py-1 text-[0.65rem] font-semibold uppercase tracking-[0.35em] text-sky-600">${time}</span>
            </div>
            <div class="flex items-center justify-between">
              <span class="text-xs uppercase tracking-[0.3em] text-slate-400">Detail</span>
              <button ${buttonAttributes} class="${buttonClasses} ${buttonDisabled ? "cursor-not-allowed" : ""}">
                <span>Log anzeigen</span>
                <span aria-hidden="true">→</span>
              </button>
            </div>
          </article>`;
      }).join("");

      container.innerHTML = cards;
    }

    async function openLogDetail(hex) {
      const targetHex = typeof hex === "string" ? hex.trim().toLowerCase() : "";
      if (!targetHex) {
        return;
      }

      activeLogSource = LOG_SOURCE_LIVE;
      updateLogSourceToggle();
      cachedLogOverview = getLogOverviewCacheForSource(LOG_SOURCE_LIVE);
      activeLogHex = targetHex;
      const container = getSettingsLogsContainer();
      if (!container) return;

      renderLogsMessage("Lade Log...");

      try {
        const response = await fetch(`/log?hex=${encodeURIComponent(targetHex)}`);
        if (response.status === 404) {
          renderLogDetail(targetHex, []);
          return;
        }
        if (!response.ok) {
          throw new Error(`Serverantwort ${response.status}`);
        }
        const data = await response.json();
        renderLogDetail(targetHex, Array.isArray(data) ? data : []);
      } catch (err) {
        console.error("[Logs] Detailansicht konnte nicht geladen werden:", err);
        const message = err && err.message ? err.message : String(err);
        const retryHex = escapeHtml(targetHex);
        container.innerHTML = `
          <div class="space-y-4">
            ${createEmptyCard(`Fehler beim Laden des Logs (${escapeHtml(message)})`)}
            <div class="flex flex-wrap justify-center gap-3">
              <button type="button" class="inline-flex items-center gap-2 rounded-2xl bg-slate-200 px-5 py-3 text-sm font-semibold text-slate-600 shadow-card transition duration-300 hover:scale-[1.02] hover:shadow-md focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-slate-300" onclick="returnToLogOverview()">Zurück</button>
              <button type="button" class="inline-flex items-center gap-2 rounded-2xl bg-brand-purple px-5 py-3 text-sm font-semibold text-white shadow-card transition duration-300 hover:scale-[1.02] hover:shadow-lg focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/50" onclick="openLogDetail('${retryHex}')">Erneut versuchen</button>
            </div>
          </div>`;
      }
    }

    function renderLogDetail(hex, data) {
      const container = getSettingsLogsContainer();
      if (!container) return;

      if (!Array.isArray(data) || data.length === 0) {
        container.innerHTML = `
          ${createEmptyCard("Keine Log-Einträge vorhanden")}
          <div class="flex justify-center">
            <button type="button" class="mt-2 inline-flex items-center gap-2 rounded-2xl bg-slate-200 px-5 py-3 text-sm font-semibold text-slate-600 shadow-card transition duration-300 hover:scale-[1.02] hover:shadow-md focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-slate-300" onclick="returnToLogOverview()">Zurück</button>
          </div>`;
        return;
      }

      const limited = Array.isArray(data) ? data.slice(-LOG_DETAIL_ROW_LIMIT).reverse() : [];
      const rows = createLogTableRows(limited);
      const totalCount = Array.isArray(data) ? data.length : 0;
      const limitNote = totalCount > limited.length
        ? `Zeige neueste ${limited.length} von ${totalCount} Einträgen`
        : `Anzahl Einträge: ${limited.length}`;

      const overviewEntry = cachedLogOverview.find(item => item && String(item.hex).toLowerCase() === hex);
      const callsign = overviewEntry && overviewEntry.last ? overviewEntry.last.callsign : (data[data.length - 1]?.callsign ?? "—");
      const headingHex = hex ? hex.toUpperCase() : "—";
      const latestLabel = escapeHtml(formatDateTime(limited[0]?.time));

      container.innerHTML = `
        <div class="space-y-6">
          <div class="flex flex-wrap items-center justify-between gap-4">
            <div class="flex items-center gap-3">
              <button type="button" onclick="returnToLogOverview()" class="inline-flex h-11 w-11 items-center justify-center rounded-2xl border border-brand-purple/20 bg-white text-brand-purple shadow-sm transition-transform duration-300 hover:scale-105 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/60" aria-label="Zurück zur Übersicht">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-5 w-5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                </svg>
              </button>
              <div>
                <p class="text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple/70">Log Detail</p>
                <h2 class="text-3xl font-semibold text-brand-ink">${escapeHtml(callsign || "Flugzeug")}</h2>
                <p class="text-sm text-slate-500">HEX ${escapeHtml(headingHex)}</p>
              </div>
            </div>
            <span class="rounded-full bg-brand-purple/10 px-4 py-2 text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple">${latestLabel}</span>
          </div>
          <div class="rounded-2xl border border-brand-purple/10 bg-white shadow-card">
            <div class="border-b border-slate-100/80 px-4 py-3 text-xs font-semibold uppercase tracking-[0.3em] text-slate-400">${escapeHtml(limitNote)}</div>
            <div class="max-h-[70dvh] overflow-auto">
              <table class="min-w-full divide-y divide-slate-100 text-left">
                <thead class="sticky top-0 bg-brand-frost/90 text-xs font-semibold uppercase tracking-[0.3em] text-slate-500">
                  <tr>
                    <th scope="col" class="px-4 py-3">Zeit</th>
                    <th scope="col" class="px-4 py-3">Callsign</th>
                    <th scope="col" class="px-4 py-3">Altitude</th>
                    <th scope="col" class="px-4 py-3">Speed</th>
                    <th scope="col" class="px-4 py-3">Position</th>
                  </tr>
                </thead>
                <tbody class="divide-y divide-slate-100/80 bg-white">
                  ${rows}
                </tbody>
              </table>
            </div>
          </div>
        </div>`;
    }

    async function openHistoryDetail(hex) {
      const targetHex = typeof hex === "string" ? hex.trim().toLowerCase() : "";
      if (!targetHex) {
        return;
      }

      activeLogSource = LOG_SOURCE_HISTORY;
      updateLogSourceToggle();
      cachedLogOverview = getLogOverviewCacheForSource(LOG_SOURCE_HISTORY);
      activeLogHex = targetHex;
      const container = getSettingsLogsContainer();
      if (!container) return;

      renderLogsMessage("Lade Historie...");

      try {
        const response = await fetch(`/history-log?hex=${encodeURIComponent(targetHex)}`);
        if (response.status === 404) {
          renderHistoryDetail(targetHex, [], null);
          return;
        }
        if (!response.ok) {
          throw new Error(`Serverantwort ${response.status}`);
        }

        const payload = await response.json();
        const records = Array.isArray(payload) ? payload : (Array.isArray(payload?.data) ? payload.data : []);
        renderHistoryDetail(targetHex, records, Array.isArray(payload) ? null : payload);
      } catch (err) {
        console.error("[Logs] Historie konnte nicht geladen werden:", err);
        const message = err && err.message ? err.message : String(err);
        container.innerHTML = `
          <div class="space-y-4">
            ${createEmptyCard(`Fehler beim Laden der Historie (${escapeHtml(message)})`)}
            <div class="flex flex-wrap justify-center gap-3">
              <button type="button" class="inline-flex items-center gap-2 rounded-2xl bg-slate-200 px-5 py-3 text-sm font-semibold text-slate-600 shadow-card transition duration-300 hover:scale-[1.02] hover:shadow-md focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-slate-300" onclick="returnToLogOverview()">Zurück</button>
              <button type="button" class="inline-flex items-center gap-2 rounded-2xl bg-brand-purple px-5 py-3 text-sm font-semibold text-white shadow-card transition duration-300 hover:scale-[1.02] hover:shadow-lg focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/50" onclick="openHistoryDetail('${escapeHtml(targetHex)}')">Erneut versuchen</button>
            </div>
          </div>`;
      }
    }

    function renderHistoryDetail(hex, data, payloadMeta) {
      const container = getSettingsLogsContainer();
      if (!container) return;

      const normalizedHex = normalizeHex(hex);
      const overviewEntry = findHistoryOverviewEntry(normalizedHex);
      const title = overviewEntry && overviewEntry.name ? overviewEntry.name : `HEX ${(normalizedHex || "").toUpperCase()}`;
      const headingHex = normalizedHex ? normalizedHex.toUpperCase() : "—";
      const records = Array.isArray(data) ? data : [];
      const limited = records.slice(-LOG_DETAIL_ROW_LIMIT).reverse();
      const rows = createLogTableRows(limited);
      const totalCount = records.length;
      const limitNote = totalCount > limited.length
        ? `Zeige neueste ${limited.length} von ${totalCount} Einträgen`
        : `Anzahl Einträge: ${limited.length}`;
      const latestLabel = limited.length > 0 ? escapeHtml(formatDateTime(limited[0].time)) : "—";

      const rangeMeta = payloadMeta && payloadMeta.range && Array.isArray(payloadMeta.range.days)
        ? payloadMeta.range
        : overviewEntry
          ? {
              limitDays: LOG_HISTORY_LIMIT_DAYS,
              totalDays: Number(overviewEntry.totalDays) || (Array.isArray(overviewEntry.days) ? overviewEntry.days.length : 0),
              days: Array.isArray(overviewEntry.days) ? overviewEntry.days : []
            }
          : {
              limitDays: LOG_HISTORY_LIMIT_DAYS,
              totalDays: 0,
              days: []
            };

      const summaryDays = Array.isArray(rangeMeta.days) ? rangeMeta.days : [];
      const summaryTotalDays = Number(rangeMeta.totalDays) || summaryDays.length;
      const summaryDaysLabel = summaryTotalDays === 1 ? "1 Tag" : `${summaryTotalDays} Tage`;
      const summaryTotalEntries = Number(payloadMeta && payloadMeta.total) || totalCount;
      const summaryEntriesLabel = summaryTotalEntries === 1 ? "1 Eintrag" : `${summaryTotalEntries} Einträge`;
      const rangeLimitLabel = rangeMeta.limitDays ? `${rangeMeta.limitDays}-Tage Limit` : "Historie";
      const lastTimestamp = payloadMeta && payloadMeta.lastTimestamp
        ? payloadMeta.lastTimestamp
        : (overviewEntry && overviewEntry.lastTimestamp ? overviewEntry.lastTimestamp : null);
      const lastTimestampLabel = lastTimestamp ? escapeHtml(formatDateTime(lastTimestamp)) : latestLabel;

      const dayBadges = summaryDays.slice(0, 6).map(day => {
        if (!day) return "";
        const dateLabel = formatDateLabel(day.date);
        const count = Number(day.recordCount) || 0;
        const badgeLabel = `${dateLabel} • ${count}`;
        return `<span class="rounded-full bg-brand-purple/10 px-3 py-1 text-[0.65rem] font-semibold uppercase tracking-[0.3em] text-brand-purple/90">${escapeHtml(badgeLabel)}</span>`;
      }).join("");
      const extraBadgeCount = summaryDays.length > 6 ? summaryDays.length - 6 : 0;
      const extraBadge = extraBadgeCount > 0
        ? `<span class="rounded-full bg-slate-200 px-3 py-1 text-[0.65rem] font-semibold uppercase tracking-[0.3em] text-slate-500">+${extraBadgeCount}</span>`
        : "";

      if (limited.length === 0) {
        container.innerHTML = `
          <div class="space-y-6">
            <div class="flex flex-wrap items-center justify-between gap-4">
              <div class="flex items-center gap-3">
                <button type="button" onclick="returnToLogOverview()" class="inline-flex h-11 w-11 items-center justify-center rounded-2xl border border-brand-purple/20 bg-white text-brand-purple shadow-sm transition-transform duration-300 hover:scale-105 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/60" aria-label="Zurück zur Übersicht">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-5 w-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                  </svg>
                </button>
                <div>
                  <p class="text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple/70">Historie</p>
                  <h2 class="text-3xl font-semibold text-brand-ink">${escapeHtml(title)}</h2>
                  <p class="text-sm text-slate-500">HEX ${escapeHtml(headingHex)}</p>
                </div>
              </div>
              <span class="rounded-full bg-brand-purple/10 px-4 py-2 text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple">14-Tage Historie</span>
            </div>
            ${createEmptyCard("Keine Historien-Daten vorhanden")}
          </div>`;
        return;
      }

      container.innerHTML = `
        <div class="space-y-6">
          <div class="flex flex-wrap items-center justify-between gap-4">
            <div class="flex items-center gap-3">
              <button type="button" onclick="returnToLogOverview()" class="inline-flex h-11 w-11 items-center justify-center rounded-2xl border border-brand-purple/20 bg-white text-brand-purple shadow-sm transition-transform duration-300 hover:scale-105 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/60" aria-label="Zurück zur Übersicht">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-5 w-5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                </svg>
              </button>
              <div>
                <p class="text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple/70">Historie</p>
                <h2 class="text-3xl font-semibold text-brand-ink">${escapeHtml(title)}</h2>
                <p class="text-sm text-slate-500">HEX ${escapeHtml(headingHex)}</p>
              </div>
            </div>
            <span class="rounded-full bg-brand-purple/10 px-4 py-2 text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple">14-Tage Historie</span>
          </div>
          <div class="grid gap-3 sm:grid-cols-2 lg:grid-cols-3">
            <div class="rounded-2xl bg-brand-frost/80 px-4 py-3 shadow-inner shadow-white/40">
              <p class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Zeitraum</p>
              <p class="mt-1 text-lg font-semibold text-brand-ink">${escapeHtml(summaryDaysLabel)}</p>
              <p class="text-xs text-slate-500">${escapeHtml(rangeLimitLabel)}</p>
            </div>
            <div class="rounded-2xl bg-brand-frost/80 px-4 py-3 shadow-inner shadow-white/40">
              <p class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Einträge</p>
              <p class="mt-1 text-lg font-semibold text-brand-ink">${escapeHtml(summaryEntriesLabel)}</p>
              <p class="text-xs text-slate-500">${escapeHtml(limitNote)}</p>
            </div>
            <div class="rounded-2xl bg-brand-frost/80 px-4 py-3 shadow-inner shadow-white/40">
              <p class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Letzte Aktualisierung</p>
              <p class="mt-1 text-lg font-semibold text-brand-ink">${lastTimestampLabel}</p>
              <p class="text-xs text-slate-500">Neueste Daten</p>
            </div>
          </div>
          <div class="flex flex-wrap items-center gap-2 text-xs uppercase tracking-[0.3em] text-slate-500">
            ${dayBadges || `<span class="rounded-full bg-slate-100 px-3 py-1 text-[0.65rem] font-semibold text-slate-400">Keine Tagesdaten</span>`}
            ${extraBadge}
          </div>
          <div class="rounded-2xl border border-brand-purple/10 bg-white shadow-card">
            <div class="border-b border-slate-100/80 px-4 py-3 text-xs font-semibold uppercase tracking-[0.3em] text-slate-400">${escapeHtml(limitNote)}</div>
            <div class="max-h-[70dvh] overflow-auto">
              <table class="min-w-full divide-y divide-slate-100 text-left">
                <thead class="sticky top-0 bg-brand-frost/90 text-xs font-semibold uppercase tracking-[0.3em] text-slate-500">
                  <tr>
                    <th scope="col" class="px-4 py-3">Zeit</th>
                    <th scope="col" class="px-4 py-3">Callsign</th>
                    <th scope="col" class="px-4 py-3">Altitude</th>
                    <th scope="col" class="px-4 py-3">Speed</th>
                    <th scope="col" class="px-4 py-3">Position</th>
                  </tr>
                </thead>
                <tbody class="divide-y divide-slate-100/80 bg-white">
                  ${rows}
                </tbody>
              </table>
            </div>
          </div>
        </div>`;
    }

    function returnToLogOverview() {
      activeLogHex = null;
      cachedLogOverview = getLogOverviewCacheForSource(activeLogSource);
      if (Array.isArray(cachedLogOverview) && cachedLogOverview.length > 0) {
        renderLogOverview(cachedLogOverview);
      } else {
        void loadLogOverview(activeLogSource);
      }
    }

    async function applyHex() {
      const input = document.getElementById("hexInput");
      const nameInput = document.getElementById("hexNameInput");
      const rawHex = input ? input.value.trim() : "";
      const hex = normalizeHex(rawHex);

      if (!hex) {
        setHexStatus("Bitte eine ICAO Hex eingeben.", "error");
        return;
      }

      const existingAircraft = getAircraftEntry(hex);
      const desiredName = nameInput ? nameInput.value.trim() : "";

      if (!existingAircraft && !desiredName) {
        setHexStatus("Bitte einen Namen für das neue Flugzeug eingeben.", "error");
        if (nameInput) nameInput.focus();
        return;
      }

      setHexStatus("Sende Anfrage...");

      try {
        if (!existingAircraft && desiredName) {
          const resAircraft = await fetch(`/aircraft/${encodeURIComponent(hex)}`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name: desiredName })
          });
          const aircraftPayload = await resAircraft.json().catch(() => ({}));
          if (!resAircraft.ok) {
            const message = aircraftPayload && aircraftPayload.error
              ? aircraftPayload.error
              : `Serverantwort ${resAircraft.status}`;
            throw new Error(message);
          }

          const savedHex = normalizeHex(aircraftPayload && aircraftPayload.hex ? aircraftPayload.hex : hex);
          const savedName = aircraftPayload && typeof aircraftPayload.name === "string" && aircraftPayload.name.trim()
            ? aircraftPayload.name.trim()
            : desiredName;

          currentAircraft = Array.isArray(currentAircraft) ? currentAircraft : [];
          currentAircraft = currentAircraft.filter(entry => normalizeHex(entry && entry.hex) !== savedHex);
          currentAircraft.push({ ...aircraftPayload, hex: savedHex, name: savedName });
          currentAircraft = dedupeAircraftEntries(currentAircraft);
          renderAircraftList(currentAircraft);
          updateAircraftFormState();
          renderHexHistoryDropdown();
        }

        const response = await fetch('/set', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ hex })
        });
        const contentType = response.headers.get("content-type") || "";
        let payload = null;

        if (contentType.includes("application/json")) {
          payload = await response.json();
        } else {
          const text = await response.text();
          payload = text ? { message: text } : {};
        }

        if (!response.ok) {
          const message = payload && typeof payload === "object"
            ? payload.error || payload.message
            : null;
          throw new Error(message || `Serverantwort ${response.status}`);
        }

        setCurrentHex(hex, { callsign: "", forceRefresh: true });
        const latest = await updateLatest();
        const aircraftName = getAircraftEntry(hex)?.name || "";
        const defaultMessage = `Neues Ziel gesetzt: ${hex}`;
        const responseMessage = payload && typeof payload === "object"
          ? payload.message || payload.error || defaultMessage
          : defaultMessage;

        setHexStatus(responseMessage, "success");
        handleHexInputChange({ skipMarkDirty: true });
      } catch (err) {
        console.error("[Settings] Fehler beim Setzen des Flugzeugs:", err);
        const message = err && err.message ? err.message : "Flugzeug konnte nicht gesetzt werden.";
        setHexStatus(message, "error");
      }
    }

    async function updateLatest() {
      try {
        const res = await fetch("/latest");
        if (!res.ok) {
          throw new Error(`Serverantwort ${res.status}`);
        }
        const d = await res.json();
        latestTelemetry = d && typeof d === "object" ? d : null;
        const telemetryCallsign = getTelemetryCallsign(latestTelemetry);
        if (latestTelemetry && latestTelemetry.hex) {
          if (telemetryCallsign) {
            setCurrentHex(latestTelemetry.hex, { callsign: telemetryCallsign });
          } else {
            setCurrentHex(latestTelemetry.hex, { keepCallsign: true });
          }
        } else if (telemetryCallsign) {
          setCurrentCallsign(telemetryCallsign);
        }
        updateFlightStatusBadgeFromLatest(latestTelemetry);
        const grid = document.getElementById("latestGrid");
        const empty = document.getElementById("latestEmpty");
        const timestampBadge = document.getElementById("latestTimestamp");
        const safe = value => {
          if (value === null || value === undefined || value === "") {
            return escapeHtml("—");
          }
          return escapeHtml(String(value));
        };

        if (timestampBadge) {
          timestampBadge.textContent = d && d.time ? formatDateTime(d.time) : "—";
        }

        if (grid) {
          if (d && d.time) {
            const fields = [
              { label: "Zeit", value: safe(formatDateTime(d.time)) },
              { label: "Callsign", value: safe(d.callsign || d.hex || "") },
              { label: "HEX", value: safe(d.hex) },
              { label: "Registration", value: safe(d.reg) },
              { label: "Type", value: safe(d.type) },
              { label: "Speed (kt)", value: safe(d.gs) },
              { label: "Altitude (ft)", value: safe(d.alt) },
              { label: "Lat", value: safe(formatCoordinate(d.lat)) },
              { label: "Lon", value: safe(formatCoordinate(d.lon)) },
              { label: "Vert. Rate", value: safe(d.vr) },
              { label: "Heading", value: safe(d.hdg) }
            ];
            const html = fields.map(field => `<div class="rounded-2xl border border-slate-100/80 bg-white/80 px-4 py-4 shadow-inner shadow-white/50">
                <span class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">${field.label}</span>
                <span class="mt-2 block text-base font-semibold text-slate-900">${field.value}</span>
              </div>`).join("");
            grid.innerHTML = html;
            if (empty) empty.classList.add("hidden");
          } else {
            grid.innerHTML = "";
            if (empty) empty.classList.remove("hidden");
          }
        }
        return d;
      } catch (err) {
        console.warn("[Latest] Aktualisierung fehlgeschlagen:", err);
        return null;
      }
    }

    async function showSettings() {
      stopSettingsInterval();
      setActiveView("settings");
      cleanupEventMap();
      activeSettingsSection = settingsSectionOrder[0] || "aircraft";

      const container = document.getElementById("content");
      if (container) {
        container.innerHTML = '<div class="settings space-y-6"><div class="settings-section rounded-3xl bg-white/90 px-6 py-5 shadow-card ring-1 ring-white/40 backdrop-blur"><p class="text-sm text-slate-600">Lade Einstellungen...</p></div></div>';
      }

      try {
        const [configData, placesData, eventsData, aircraftData] = await Promise.all([
          fetchConfig(),
          fetchPlaces(),
          fetchEventsList(),
          fetchAircraftList()
        ]);
        currentConfigCache = configData;
        syncNotificationPreferencesFromConfig(currentConfigCache);
        currentPlaces = Array.isArray(placesData) ? placesData : [];
        currentEvents = Array.isArray(eventsData) ? eventsData : [];
        currentAircraft = dedupeAircraftEntries(Array.isArray(aircraftData) ? aircraftData : []);
        editingPlaceId = null;
        editingAircraftHex = null;
        renderSettingsView(currentConfigCache, currentPlaces, currentEvents, currentAircraft);
        void updateLatest();
        settingsInterval = setInterval(() => { void updateLatest(); }, 3000);
      } catch (err) {
        console.error("[Settings] Fehler beim Laden:", err);
        if (container) {
          const message = err && err.message ? err.message : String(err);
          container.innerHTML = `<div class="settings space-y-6"><div class="settings-section rounded-3xl bg-white/90 px-6 py-5 shadow-card ring-1 ring-white/40 backdrop-blur"><p class="text-sm text-rose-500">Fehler beim Laden der Einstellungen: ${escapeHtml(message)}</p></div></div>`;
        }
      }
    }

    function renderSettingsView(config, places, events = [], aircraftList = []) {
      const container = document.getElementById("content");
      if (!container) return;

      const safeConfig = config || {};

      currentPlaces = Array.isArray(places) ? places : [];
      currentEvents = Array.isArray(events) ? events : [];
      currentAircraft = dedupeAircraftEntries(Array.isArray(aircraftList) ? aircraftList : []);

      if (!settingsSectionOrder.includes(activeSettingsSection)) {
        activeSettingsSection = settingsSectionOrder[0] || "aircraft";
      }

      const navButtons = [
        { id: "aircraft", label: "Flugzeuge verwalten", description: "Hex setzen, Namen & letzter Datensatz" },
        { id: "thresholds", label: "Schwellwerte", description: "Grenzwerte für Events festlegen" },
        { id: "notifications", label: "Benachrichtigungen", description: "Push-Benachrichtigungen konfigurieren" },
        { id: "places", label: "Orte verwalten", description: "Eigene Landeplätze pflegen" },
        { id: "events", label: "Events verwalten", description: "Takeoffs & Landings administrieren" },
        { id: "logs", label: "Logs & Rohdaten", description: "Letzte Flugdaten einsehen" }
      ];

      const navHtml = `
        <div class="rounded-3xl bg-white/80 px-4 py-4 shadow-card ring-1 ring-white/40 backdrop-blur">
          <div class="grid gap-3 sm:grid-cols-2 lg:grid-cols-4">
            ${navButtons.map(button => `
              <button
                type="button"
                data-settings-tab="${button.id}"
                onclick="selectSettingsSection('${button.id}')"
                class="settings-tab flex flex-col items-start gap-1 rounded-2xl border px-4 py-3 text-left transition duration-300">
                <span class="text-xs font-semibold uppercase tracking-[0.35em] text-brand-purple/70">${button.label}</span>
                <span class="text-[0.75rem] font-medium text-slate-600">${button.description}</span>
              </button>
            `).join("")}
          </div>
        </div>
      `;

      const html = `
        <div class="settings space-y-6">
          ${navHtml}
          <section data-settings-section="aircraft" class="space-y-6 ${activeSettingsSection === "aircraft" ? "" : "hidden"}">
            <section class="settings-section rounded-3xl bg-white/95 px-6 py-6 shadow-card ring-1 ring-white/50 backdrop-blur">
              <div class="flex flex-col gap-1">
                <span class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Live Ziel</span>
                <h3 class="text-xl font-semibold text-slate-900">Flugzeug setzen</h3>
                <p class="text-sm text-slate-500">Wähle die aktuelle ICAO Hex für den Live-Feed.</p>
              </div>
              <div class="mt-6 space-y-4">
                <div>
                  <label for="hexInput" class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">ICAO Hex</label>
                  <input id="hexInput" type="text" placeholder="ICAO Hex" value="${escapeHtml(currentHex)}" class="mt-2 w-full rounded-2xl border border-slate-200/70 bg-white/80 px-4 py-3 text-base text-slate-900 shadow-inner shadow-white/40 transition focus:border-brand-purple focus:outline-none focus:ring-2 focus:ring-brand-purple/40" />
                </div>
                <p id="hexNameInfo" class="hidden text-xs font-semibold uppercase tracking-[0.3em] text-slate-400"></p>
                <div id="hexNameWrapper" class="hidden">
                  <label for="hexNameInput" class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">Name des Flugzeugs</label>
                  <input id="hexNameInput" type="text" placeholder="z. B. Rettungshubschrauber" class="mt-2 w-full rounded-2xl border border-slate-200/70 bg-white/80 px-4 py-3 text-base text-slate-900 shadow-inner shadow-white/40 transition focus:border-brand-purple focus:outline-none focus:ring-2 focus:ring-brand-purple/40" />
                  <p class="mt-2 text-xs text-slate-500">Dieser Name wird für die Übersicht gespeichert.</p>
                </div>
                <div id="hexHistoryWrapper" class="hidden space-y-2">
                  <label class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400" for="hexHistorySelect">Gespeicherte Flugzeuge</label>
                  <select id="hexHistorySelect" class="w-full rounded-2xl border border-slate-200/70 bg-white/80 px-4 py-3 text-base text-slate-900 transition focus:border-brand-purple focus:outline-none focus:ring-2 focus:ring-brand-purple/40" onchange="handleHexHistorySelection(event)"></select>
                </div>
                <button class="inline-flex w-full items-center justify-center rounded-2xl bg-brand-red px-5 py-3 text-sm font-semibold uppercase tracking-[0.35em] text-white shadow-lg shadow-brand-red/40 transition duration-300 hover:scale-[1.02] hover:bg-brand-red/90 hover:shadow-brand-red/60 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-red/70" onclick="applyHex()">Flugzeug setzen</button>
                <p id="hexStatus" class="min-h-[1.5rem] text-sm font-semibold text-slate-500"></p>
              </div>
            </section>
            <section class="settings-section rounded-3xl bg-white/95 px-6 py-6 shadow-card ring-1 ring-white/50 backdrop-blur">
              <div class="flex flex-col gap-2 lg:flex-row lg:items-center lg:justify-between">
                <div>
                  <span class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Flottenübersicht</span>
                  <h3 class="text-xl font-semibold text-slate-900">Flugzeuge verwalten</h3>
                  <p class="text-sm text-slate-500">Benenne gespeicherte Hex-Codes um und behalte den Überblick.</p>
                </div>
                <button type="button" class="inline-flex items-center gap-2 rounded-full bg-sky-100 px-4 py-2 text-xs font-semibold uppercase tracking-[0.35em] text-sky-700 shadow-inner shadow-white/40 transition duration-300 hover:bg-sky-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-200" onclick="refreshAircraftList()">
                  Aktualisieren
                </button>
              </div>
              <div id="aircraftList" class="mt-6 space-y-3"></div>
              <p id="aircraftEmpty" class="mt-4 hidden text-sm text-slate-500">Keine Flugzeuge gespeichert.</p>
              <p id="aircraftMessage" class="mt-4 min-h-[1.5rem] text-sm font-semibold text-slate-500"></p>
              <form id="aircraftForm" onsubmit="submitAircraft(event)" class="mt-6 hidden rounded-3xl border border-slate-100/70 bg-white/80 px-6 py-6 shadow-inner shadow-white/60">
                <h4 id="aircraftFormTitle" class="text-lg font-semibold text-slate-900">Flugzeug auswählen</h4>
                <p id="aircraftFormHelper" class="mt-2 text-sm text-slate-500">Wähle ein Flugzeug aus der Liste zum Bearbeiten.</p>
                <div class="mt-4 space-y-4">
                  <div>
                    <span class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">HEX</span>
                    <div id="aircraftHexDisplay" class="mt-2 rounded-2xl border border-slate-200/70 bg-white/80 px-4 py-3 text-base font-semibold text-slate-900 shadow-inner shadow-white/40">—</div>
                  </div>
                  <div>
                    <label for="aircraftName" class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">Name</label>
                    <input id="aircraftName" type="text" class="mt-2 w-full rounded-2xl border border-slate-200/70 bg-white/80 px-4 py-3 text-base text-slate-900 transition focus:border-brand-purple focus:outline-none focus:ring-2 focus:ring-brand-purple/40" disabled />
                  </div>
                </div>
                <div class="mt-6 flex flex-wrap items-center gap-3">
                  <button id="aircraftSubmit" type="submit" class="inline-flex flex-1 items-center justify-center rounded-2xl bg-brand-red px-5 py-3 text-sm font-semibold uppercase tracking-[0.35em] text-white shadow-lg shadow-brand-red/40 transition duration-300 hover:scale-[1.02] hover:bg-brand-red/90 hover:shadow-brand-red/60 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-red/70" disabled>Speichern</button>
                  <button id="aircraftCancel" type="button" class="hidden rounded-2xl border border-brand-red/30 bg-white/70 px-5 py-3 text-sm font-semibold uppercase tracking-[0.35em] text-brand-red transition duration-300 hover:bg-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-red/40" onclick="cancelAircraftEdit()">Abbrechen</button>
                </div>
                <p id="aircraftFormMessage" class="mt-4 min-h-[1.5rem] text-sm font-semibold text-slate-500"></p>
              </form>
            </section>
            <section class="settings-section rounded-3xl bg-white/95 px-6 py-6 shadow-card ring-1 ring-white/50 backdrop-blur">
              <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                <div>
                  <span class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Telemetry Snapshot</span>
                  <h3 class="text-xl font-semibold text-slate-900">Letzter Datensatz</h3>
                </div>
                <span id="latestTimestamp" class="inline-flex items-center rounded-full bg-sky-100 px-4 py-2 text-xs font-semibold uppercase tracking-[0.35em] text-sky-700 shadow-inner shadow-white/40">—</span>
              </div>
              <div id="latestGrid" class="mt-6 grid gap-3 sm:grid-cols-2 xl:grid-cols-3 2xl:grid-cols-4"></div>
              <p id="latestEmpty" class="mt-4 hidden text-sm text-slate-500">Noch kein Datensatz verfügbar.</p>
            </section>
          </section>
          <section data-settings-section="thresholds" class="${activeSettingsSection === "thresholds" ? "" : "hidden"}">
            <section class="settings-section rounded-3xl bg-white/95 px-6 py-6 shadow-card ring-1 ring-white/50 backdrop-blur">
              <div class="flex flex-col gap-1">
                <span class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Überwachung</span>
                <h3 class="text-xl font-semibold text-slate-900">Schwellwerte</h3>
                <p class="text-sm text-slate-500">Passe die Trigger für Events und Warnungen an.</p>
              </div>
              <form id="configForm" onsubmit="submitConfig(event)" class="mt-6 space-y-5">
                <div class="grid gap-4 md:grid-cols-2 xl:grid-cols-4">
                  <div class="group rounded-2xl border border-slate-100/80 bg-white/80 px-4 py-4 shadow-inner shadow-white/50 transition focus-within:border-brand-purple/40 focus-within:shadow-brand-purple/10">
                    <label for="cfgAltitude" class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">Höhen-Schwelle (ft)</label>
                    <input id="cfgAltitude" type="number" min="1" step="1" required class="mt-3 w-full bg-transparent text-base font-semibold text-slate-900 placeholder:text-slate-400 focus:outline-none" />
                  </div>
                  <div class="group rounded-2xl border border-slate-100/80 bg-white/80 px-4 py-4 shadow-inner shadow-white/50 transition focus-within:border-brand-purple/40 focus-within:shadow-brand-purple/10">
                    <label for="cfgSpeed" class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">Geschwindigkeits-Schwelle (kt)</label>
                    <input id="cfgSpeed" type="number" min="0" step="1" required class="mt-3 w-full bg-transparent text-base font-semibold text-slate-900 placeholder:text-slate-400 focus:outline-none" />
                  </div>
                  <div class="group rounded-2xl border border-slate-100/80 bg-white/80 px-4 py-4 shadow-inner shadow-white/50 transition focus-within:border-brand-purple/40 focus-within:shadow-brand-purple/10">
                    <label for="cfgTimeout" class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">Offline-Timeout (Sek.)</label>
                    <input id="cfgTimeout" type="number" min="5" step="1" required class="mt-3 w-full bg-transparent text-base font-semibold text-slate-900 placeholder:text-slate-400 focus:outline-none" />
                  </div>
                  <div class="group rounded-2xl border border-slate-100/80 bg-white/80 px-4 py-4 shadow-inner shadow-white/50 transition focus-within:border-brand-purple/40 focus-within:shadow-brand-purple/10">
                    <label for="cfgRadius" class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">Radius für Ortszuordnung (m)</label>
                    <input id="cfgRadius" type="number" min="1" step="1" required class="mt-3 w-full bg-transparent text-base font-semibold text-slate-900 placeholder:text-slate-400 focus:outline-none" />
                  </div>
                </div>
                <div class="group rounded-2xl border border-slate-100/80 bg-white/80 px-4 py-4 shadow-inner shadow-white/50 transition focus-within:border-brand-purple/40 focus-within:shadow-brand-purple/10">
                  <label for="cfgHistoryHeader" class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">ADS-B Exchange Verlauf-Header</label>
                  <textarea id="cfgHistoryHeader" rows="3" spellcheck="false" class="mt-3 w-full resize-y bg-transparent text-sm text-slate-900 placeholder:text-slate-400 focus:outline-none" placeholder="Cookie: adsbx_session=..."></textarea>
                  <p class="mt-3 text-xs leading-relaxed text-slate-500">Melde dich bei ADS-B Exchange an, öffne die Globe-Historie im Browser und wähle in den Entwicklertools den passenden <em>globe_history</em>-Request aus. Kopiere aus den Request Headers den Eintrag <span class="font-semibold text-slate-600">cookie</span> (oder einen anderen Authentifizierungs-Header) und füge ihn hier ein. Du kannst entweder den kompletten Header (<code>Cookie: …</code>) oder nur den Wert eintragen. Lass das Feld leer, wenn keine Anmeldung erforderlich ist.</p>
                </div>
                <button type="submit" class="inline-flex w-full items-center justify-center rounded-2xl bg-brand-red px-5 py-3 text-sm font-semibold uppercase tracking-[0.35em] text-white shadow-lg shadow-brand-red/40 transition duration-300 hover:scale-[1.02] hover:bg-brand-red/90 hover:shadow-brand-red/60 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-red/70">Konfiguration speichern</button>
              </form>
              <p id="configMessage" class="mt-2 min-h-[1.5rem] text-sm font-semibold text-slate-500"></p>
            </section>
          </section>
          <section data-settings-section="notifications" class="${activeSettingsSection === "notifications" ? "" : "hidden"}">
            <section class="settings-section rounded-3xl bg-white/95 px-6 py-6 shadow-card ring-1 ring-white/50 backdrop-blur">
              <div class="flex flex-col gap-1">
                <span class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">iPhone Push</span>
                <h3 class="text-xl font-semibold text-slate-900">Benachrichtigungen</h3>
                <p class="text-sm text-slate-500">Erhalte Hinweise, wenn Starts oder Landungen erkannt werden.</p>
              </div>
              <div class="mt-6 space-y-5">
                <div class="rounded-3xl border border-slate-100/80 bg-white/80 px-5 py-5 shadow-inner shadow-white/50">
                  <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                    <div>
                      <h4 class="text-base font-semibold text-slate-900">Benachrichtigungen aktivieren</h4>
                      <p id="notificationsSupportHint" class="mt-1 text-xs font-semibold text-slate-500">Prüfe die Berechtigungen deines Geräts.</p>
                    </div>
                    <label class="relative inline-flex cursor-pointer items-center">
                      <input id="notificationsEnabled" type="checkbox" class="peer sr-only" />
                      <span class="h-11 w-20 rounded-full bg-slate-200 transition-all duration-300 peer-checked:bg-brand-purple/80"></span>
                      <span class="absolute left-1 top-1 h-9 w-9 rounded-full bg-white shadow-md transition-all duration-300 peer-checked:translate-x-9"></span>
                    </label>
                  </div>
                </div>
                <div class="rounded-3xl border border-slate-100/80 bg-white/80 px-5 py-5 shadow-inner shadow-white/50">
                  <h4 class="text-base font-semibold text-slate-900">Auslöser</h4>
                  <div class="mt-4 grid gap-3 sm:grid-cols-2">
                    <label class="flex items-center justify-between gap-3 rounded-2xl border border-slate-200/70 bg-white/70 px-4 py-3 shadow-inner shadow-white/40">
                      <span class="text-sm font-semibold text-slate-700">Takeoff erkannt</span>
                      <input id="notificationsTakeoff" type="checkbox" class="h-5 w-5 rounded border-slate-300 text-brand-purple focus:ring-brand-purple/60" />
                    </label>
                    <label class="flex items-center justify-between gap-3 rounded-2xl border border-slate-200/70 bg-white/70 px-4 py-3 shadow-inner shadow-white/40">
                      <span class="text-sm font-semibold text-slate-700">Landing erkannt</span>
                      <input id="notificationsLanding" type="checkbox" class="h-5 w-5 rounded border-slate-300 text-brand-purple focus:ring-brand-purple/60" />
                    </label>
                  </div>
                </div>
                <div class="rounded-3xl border border-slate-100/80 bg-white/80 px-5 py-5 shadow-inner shadow-white/50">
                  <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                    <div>
                      <h4 class="text-base font-semibold text-slate-900">Debug Modus</h4>
                      <p class="text-xs text-slate-500">Blendt einen Test-Button in Eventdetails ein und löst Benachrichtigungen verzögert aus.</p>
                    </div>
                    <label class="relative inline-flex cursor-pointer items-center">
                      <input id="notificationsDebug" type="checkbox" class="peer sr-only" />
                      <span class="h-11 w-20 rounded-full bg-slate-200 transition-all duration-300 peer-checked:bg-amber-400/80"></span>
                      <span class="absolute left-1 top-1 h-9 w-9 rounded-full bg-white shadow-md transition-all duration-300 peer-checked:translate-x-9"></span>
                    </label>
                  </div>
                </div>
                <div class="rounded-3xl border border-slate-100/80 bg-white/80 px-5 py-5 shadow-inner shadow-white/50">
                  <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                    <div>
                      <h4 class="text-base font-semibold text-slate-900">Testen</h4>
                      <p class="text-xs text-slate-500">Sende eine Probe-Benachrichtigung an dein Gerät.</p>
                    </div>
                    <button id="notificationsTestButton" type="button" class="inline-flex items-center gap-2 rounded-2xl bg-brand-purple px-5 py-3 text-sm font-semibold uppercase tracking-[0.35em] text-white shadow-lg shadow-brand-purple/40 transition duration-300 hover:scale-[1.02] hover:bg-brand-purple/90 hover:shadow-brand-purple/60 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/70">Test Benachrichtigung</button>
                  </div>
                </div>
              </div>
              <p id="notificationsMessage" class="mt-4 min-h-[1.5rem] text-sm font-semibold text-slate-500"></p>
            </section>
          </section>
          <section data-settings-section="places" class="${activeSettingsSection === "places" ? "" : "hidden"}">
            <section class="settings-section rounded-3xl bg-white/95 px-6 py-6 shadow-card ring-1 ring-white/50 backdrop-blur">
              <div class="flex flex-col gap-2 lg:flex-row lg:items-center lg:justify-between">
                <div>
                  <span class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Orte verwalten</span>
                  <h3 class="text-xl font-semibold text-slate-900">Orte</h3>
                  <p class="text-sm text-slate-500">Verwalte deine eigenen Landeplätze und Referenzpunkte.</p>
                </div>
                <button type="button" class="inline-flex items-center gap-2 rounded-full bg-sky-100 px-4 py-2 text-xs font-semibold uppercase tracking-[0.35em] text-sky-700 shadow-inner shadow-white/40 transition duration-300 hover:bg-sky-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-200" onclick="refreshPlaces()">
                  Aktualisieren
                </button>
              </div>
              <div id="placesList" class="mt-6 space-y-3"></div>
              <p id="placesEmpty" class="mt-4 hidden text-sm text-slate-500">Keine Orte vorhanden.</p>
              <div class="mt-8 grid gap-4 lg:grid-cols-2">
                <form id="placeForm" onsubmit="submitPlace(event)" class="rounded-3xl border border-slate-100/70 bg-white/80 px-6 py-6 shadow-inner shadow-white/60">
                  <h4 id="placeFormTitle" class="text-lg font-semibold text-slate-900">Neuen Ort hinzufügen</h4>
                  <div class="mt-4 space-y-4">
                    <div>
                      <label class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400" for="placeName">Name</label>
                      <input id="placeName" type="text" class="mt-2 w-full rounded-2xl border border-slate-200/70 bg-white/80 px-4 py-3 text-base text-slate-900 transition focus:border-brand-purple focus:outline-none focus:ring-2 focus:ring-brand-purple/40" required />
                    </div>
                    <div>
                      <label class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400" for="placeType">Typ</label>
                      <input id="placeType" type="text" class="mt-2 w-full rounded-2xl border border-slate-200/70 bg-white/80 px-4 py-3 text-base text-slate-900 transition focus:border-brand-purple focus:outline-none focus:ring-2 focus:ring-brand-purple/40" required />
                    </div>
                    <div class="grid gap-4 sm:grid-cols-2">
                      <div>
                        <label class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400" for="placeLat">Lat</label>
                        <input id="placeLat" type="number" step="any" class="mt-2 w-full rounded-2xl border border-slate-200/70 bg-white/80 px-4 py-3 text-base text-slate-900 transition focus:border-brand-purple focus:outline-none focus:ring-2 focus:ring-brand-purple/40" required />
                      </div>
                      <div>
                        <label class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400" for="placeLon">Lon</label>
                        <input id="placeLon" type="number" step="any" class="mt-2 w-full rounded-2xl border border-slate-200/70 bg-white/80 px-4 py-3 text-base text-slate-900 transition focus:border-brand-purple focus:outline-none focus:ring-2 focus:ring-brand-purple/40" required />
                      </div>
                    </div>
                    <div id="placeRadiusRow" class="hidden">
                      <label class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400" for="placeRadius">Individueller Radius (m)</label>
                      <input id="placeRadius" type="number" min="1" step="1" class="mt-2 w-full rounded-2xl border border-slate-200/70 bg-white/80 px-4 py-3 text-base text-slate-900 transition focus:border-brand-purple focus:outline-none focus:ring-2 focus:ring-brand-purple/40" disabled />
                      <p id="placeRadiusHelper" class="mt-2 text-xs text-slate-500"></p>
                    </div>
                  </div>
                  <div class="mt-6 flex flex-wrap items-center gap-3">
                    <button id="placeSubmit" type="submit" class="inline-flex flex-1 items-center justify-center rounded-2xl bg-brand-red px-5 py-3 text-sm font-semibold uppercase tracking-[0.35em] text-white shadow-lg shadow-brand-red/40 transition duration-300 hover:scale-[1.02] hover:bg-brand-red/90 hover:shadow-brand-red/60 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-red/70">Hinzufügen</button>
                    <button id="placeCancel" type="button" class="hidden rounded-2xl border border-brand-red/30 bg-white/70 px-5 py-3 text-sm font-semibold uppercase tracking-[0.35em] text-brand-red transition duration-300 hover:bg-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-red/40" onclick="cancelPlaceEdit()">Abbrechen</button>
                  </div>
                  <p id="placeFormMessage" class="mt-4 min-h-[1.5rem] text-sm font-semibold text-slate-500"></p>
                </form>
                <div class="rounded-3xl border border-slate-100/70 bg-brand-frost/70 px-6 py-6 shadow-inner shadow-white/60">
                  <h4 class="text-lg font-semibold text-slate-900">Ort suchen</h4>
                  <div class="mt-4 flex flex-col gap-3 sm:flex-row sm:items-center">
                    <input id="placeSearch" type="text" placeholder="Ort suchen" class="flex-1 rounded-2xl border border-slate-200/70 bg-white/80 px-4 py-3 text-base text-slate-900 transition focus:border-brand-purple focus:outline-none focus:ring-2 focus:ring-brand-purple/40" onkeydown="handlePlaceSearchKey(event)" />
                    <button type="button" class="inline-flex items-center justify-center rounded-2xl bg-brand-purple px-5 py-3 text-sm font-semibold uppercase tracking-[0.35em] text-white shadow-lg shadow-brand-purple/40 transition duration-300 hover:scale-[1.02] hover:bg-brand-purple/90 hover:shadow-brand-purple/60 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/70" onclick="searchPlaceInOSM()">Suche</button>
                  </div>
                  <p id="placeSearchStatus" class="mt-3 min-h-[1.5rem] text-sm font-semibold text-slate-500"></p>
                  <div id="placeSearchResults" class="mt-4 flex flex-col gap-3"></div>
                </div>
              </div>
            </section>
          </section>
          <section data-settings-section="events" class="${activeSettingsSection === "events" ? "" : "hidden"}">
            <section class="settings-section rounded-3xl bg-white/95 px-6 py-6 shadow-card ring-1 ring-white/50 backdrop-blur">
              <div class="flex flex-col gap-2 lg:flex-row lg:items-center lg:justify-between">
                <div>
                  <span class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Events</span>
                  <h3 class="text-xl font-semibold text-slate-900">Events verwalten</h3>
                  <p class="text-sm text-slate-500">Lösche erkannte Takeoff- und Landing-Events.</p>
                </div>
                <button type="button" class="inline-flex items-center gap-2 rounded-full bg-sky-100 px-4 py-2 text-xs font-semibold uppercase tracking-[0.35em] text-sky-700 shadow-inner shadow-white/40 transition duration-300 hover:bg-sky-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-200" onclick="refreshEventsForSettings()">
                  Aktualisieren
                </button>
              </div>
              <div id="eventsList" class="mt-6 space-y-3"></div>
              <p id="eventsEmpty" class="mt-4 hidden text-sm text-slate-500">Keine Events vorhanden.</p>
              <p id="eventsMessage" class="mt-4 min-h-[1.5rem] text-sm font-semibold text-slate-500"></p>
            </section>
          </section>
          <section data-settings-section="logs" class="${activeSettingsSection === "logs" ? "" : "hidden"}">
            <section class="settings-section rounded-3xl bg-white/95 px-6 py-6 shadow-card ring-1 ring-white/50 backdrop-blur">
              <div class="flex flex-col gap-2 lg:flex-row lg:items-center lg:justify-between">
                <div>
                  <span class="text-[0.65rem] uppercase tracking-[0.35em] text-brand-purple/70">Logs</span>
                  <h3 class="text-xl font-semibold text-slate-900">Flugdatensätze</h3>
                  <p class="text-sm text-slate-500">Analysiere die letzten Rohdaten deiner Flüge.</p>
                </div>
                <button type="button" class="inline-flex items-center gap-2 rounded-full bg-sky-100 px-4 py-2 text-xs font-semibold uppercase tracking-[0.35em] text-sky-700 shadow-inner shadow-white/40 transition duration-300 hover:bg-sky-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-200" onclick="loadLogOverview()">
                  Aktualisieren
                </button>
              </div>
              <div class="mt-6 flex flex-wrap items-center justify-between gap-3">
                <div class="inline-flex items-center gap-2 rounded-3xl bg-white/70 p-1 shadow-inner shadow-white/50">
                  <button type="button" data-log-source="live" onclick="switchLogSource('live')" class="log-source-toggle inline-flex items-center gap-2 rounded-2xl px-4 py-2 text-sm font-semibold transition duration-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/50">Live Log</button>
                  <button type="button" data-log-source="history" onclick="switchLogSource('history')" class="log-source-toggle inline-flex items-center gap-2 rounded-2xl px-4 py-2 text-sm font-semibold transition duration-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/50">
                    <span>Historie</span>
                    <span class="rounded-full bg-brand-purple/10 px-2 py-0.5 text-[0.65rem] font-semibold uppercase tracking-[0.35em] text-brand-purple">14-Tage Historie</span>
                  </button>
                </div>
              </div>
              <div id="settingsLogsContainer" class="mt-6 space-y-4"></div>
            </section>
          </section>
        </div>
      `;

      container.innerHTML = html;

      const altitudeInput = document.getElementById("cfgAltitude");
      const speedInput = document.getElementById("cfgSpeed");
      const timeoutInput = document.getElementById("cfgTimeout");
      const radiusInput = document.getElementById("cfgRadius");
      const historyHeaderInput = document.getElementById("cfgHistoryHeader");
      if (altitudeInput) altitudeInput.value = safeConfig.altitudeThresholdFt || "";
      if (speedInput) speedInput.value = safeConfig.speedThresholdKt || "";
      if (timeoutInput) timeoutInput.value = safeConfig.offlineTimeoutSec || "";
      if (radiusInput) radiusInput.value = safeConfig.placeMatchRadiusMeters || "";
      if (historyHeaderInput) historyHeaderInput.value = safeConfig.adsbHistoryAuthHeader || "";

      initializeNotificationSettingsControls();
      updateNotificationControlsFromState();

      const hexInput = document.getElementById("hexInput");
      if (hexInput) {
        hexInput.addEventListener("input", handleHexInputChange);
        hexInputDirty = false;
      }

      renderPlacesTable(currentPlaces);
      updatePlaceFormState();
      renderAircraftList(currentAircraft);
      updateAircraftFormState();
      renderHexHistoryDropdown();
      handleHexInputChange({ skipMarkDirty: true });
      renderEventsManagementTable(currentEvents);
      updateLogSourceToggle();
      loadLogOverview(activeLogSource);
      updateSettingsSectionVisibility();
    }

    function initializeNotificationSettingsControls() {
      const enabledInput = document.getElementById("notificationsEnabled");
      const takeoffInput = document.getElementById("notificationsTakeoff");
      const landingInput = document.getElementById("notificationsLanding");
      const testButton = document.getElementById("notificationsTestButton");
      const debugInput = document.getElementById("notificationsDebug");

      if (enabledInput) {
        enabledInput.addEventListener("change", handleNotificationsEnabledChange);
      }
      if (takeoffInput) {
        takeoffInput.addEventListener("change", handleNotificationsTakeoffChange);
      }
      if (landingInput) {
        landingInput.addEventListener("change", handleNotificationsLandingChange);
      }
      if (testButton) {
        testButton.addEventListener("click", triggerNotificationTest);
      }
      if (debugInput) {
        debugInput.addEventListener("change", handleNotificationDebugToggle);
      }
    }

    function updateNotificationSupportHint() {
      const hint = document.getElementById("notificationsSupportHint");
      if (!hint) {
        return;
      }

      const baseClass = "mt-1 text-xs font-semibold";
      if (!isNotificationSupported()) {
        hint.className = `${baseClass} text-rose-500`;
        hint.textContent = "Benachrichtigungen werden von diesem Gerät oder Browser nicht unterstützt.";
        return;
      }

      if (Notification.permission === "denied") {
        hint.className = `${baseClass} text-rose-500`;
        hint.textContent = "Benachrichtigungen sind blockiert. Bitte in den Einstellungen freigeben.";
      } else if (Notification.permission === "granted") {
        hint.className = `${baseClass} text-emerald-600`;
        hint.textContent = "Bereit für Benachrichtigungen. Du kannst die Auslöser unten wählen.";
      } else {
        hint.className = `${baseClass} text-slate-500`;
        hint.textContent = "Erlaube Benachrichtigungen, um Push-Hinweise auf deinem iPhone zu erhalten.";
      }
    }

    function updateNotificationControlsFromState() {
      const enabledInput = document.getElementById("notificationsEnabled");
      const takeoffInput = document.getElementById("notificationsTakeoff");
      const landingInput = document.getElementById("notificationsLanding");
      const debugInput = document.getElementById("notificationsDebug");

      const supported = isNotificationSupported();
      const permissionDenied = supported && typeof Notification !== "undefined" && Notification.permission === "denied";
      const enabled = supported && !permissionDenied && !!(notificationPreferences && notificationPreferences.enabled);

      if (enabledInput) {
        enabledInput.checked = enabled;
        enabledInput.disabled = !supported || permissionDenied;
      }

      if (takeoffInput) {
        takeoffInput.checked = !!(notificationPreferences && notificationPreferences.notifyOnTakeoff);
        takeoffInput.disabled = !supported || !enabled;
      }

      if (landingInput) {
        landingInput.checked = !!(notificationPreferences && notificationPreferences.notifyOnLanding);
        landingInput.disabled = !supported || !enabled;
      }

      if (debugInput) {
        debugInput.checked = !!notificationDebugMode;
      }

      updateNotificationSupportHint();
    }

    function showNotificationMessage(message, type = "") {
      const el = document.getElementById("notificationsMessage");
      if (!el) return;
      let color = "text-slate-500";
      if (type === "success") {
        color = "text-emerald-600";
      } else if (type === "error") {
        color = "text-rose-500";
      }
      el.className = `mt-4 min-h-[1.5rem] text-sm font-semibold ${color}`;
      el.textContent = message || "";
    }

    async function persistNotificationPreferences() {
      if (!currentConfigCache) {
        currentConfigCache = {};
      }
      showNotificationMessage("Speichere...", "");
      const payload = buildConfigRequestPayload({
        notificationsEnabled: notificationPreferences.enabled,
        notifyOnTakeoff: notificationPreferences.notifyOnTakeoff,
        notifyOnLanding: notificationPreferences.notifyOnLanding
      });

      try {
        const res = await fetch("/config", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data && data.error ? data.error : `Serverantwort ${res.status}`);
        }

        currentConfigCache = data;
        syncNotificationPreferencesFromConfig(data);
        updateNotificationControlsFromState();
        showNotificationMessage("Benachrichtigungseinstellungen gespeichert.", "success");
      } catch (err) {
        console.error("[Notifications] Speichern fehlgeschlagen:", err);
        syncNotificationPreferencesFromConfig(currentConfigCache || {});
        updateNotificationControlsFromState();
        const message = err && err.message ? err.message : String(err);
        showNotificationMessage(`Speichern fehlgeschlagen: ${message}`, "error");
      }
    }

    async function handleNotificationsEnabledChange(event) {
      if (!isNotificationSupported()) {
        if (event && event.target) {
          event.target.checked = false;
        }
        showNotificationMessage("Benachrichtigungen werden nicht unterstützt.", "error");
        return;
      }

      const checked = !!(event && event.target && event.target.checked);
      if (checked) {
        const granted = await ensureNotificationPermission();
        if (!granted) {
          if (event && event.target) {
            event.target.checked = false;
          }
          notificationPreferences.enabled = false;
          updateNotificationControlsFromState();
          showNotificationMessage("Berechtigung nicht erteilt. Bitte in den Einstellungen freigeben.", "error");
          return;
        }
        notificationPreferences.enabled = true;
      } else {
        notificationPreferences.enabled = false;
      }

      updateNotificationControlsFromState();
      await persistNotificationPreferences();
    }

    async function handleNotificationsTakeoffChange(event) {
      notificationPreferences.notifyOnTakeoff = !!(event && event.target && event.target.checked);
      updateNotificationControlsFromState();
      await persistNotificationPreferences();
    }

    async function handleNotificationsLandingChange(event) {
      notificationPreferences.notifyOnLanding = !!(event && event.target && event.target.checked);
      updateNotificationControlsFromState();
      await persistNotificationPreferences();
    }

    function handleNotificationDebugToggle(event) {
      notificationDebugMode = !!(event && event.target && event.target.checked);
      saveNotificationDebugMode(notificationDebugMode);

      if (activeView === "events" && activeEventDetail) {
        renderEventDetail(activeEventDetail, eventDetailReturnState.groupKey || null);
      }
    }

    async function triggerNotificationTest() {
      if (!isNotificationSupported()) {
        showNotificationMessage("Benachrichtigungen werden nicht unterstützt.", "error");
        return;
      }

      const granted = await ensureNotificationPermission();
      updateNotificationSupportHint();
      if (!granted) {
        showNotificationMessage("Bitte erlaube Benachrichtigungen, um den Test zu nutzen.", "error");
        return;
      }

      const registration = await ensureServiceWorkerReady();
      if (!registration) {
        showNotificationMessage("Service Worker konnte nicht vorbereitet werden.", "error");
        return;
      }

      try {
        await registration.showNotification("Testbenachrichtigung", {
          body: "Dies ist eine Probe für Push-Mitteilungen des Heli Trackers.",
          icon: "/icons/icon-192.png",
          badge: "/icons/icon-192.png",
          tag: `heli-tracker-test-${Date.now()}`,
          data: { url: window.location.origin }
        });
        showNotificationMessage("Testbenachrichtigung wurde gesendet.", "success");
      } catch (err) {
        console.error("[Notifications] Testbenachrichtigung fehlgeschlagen:", err);
        const message = err && err.message ? err.message : String(err);
        showNotificationMessage(`Test fehlgeschlagen: ${message}`, "error");
      }
    }

    async function fetchConfig() {
      const res = await fetch("/config");
      if (!res.ok) {
        throw new Error(`Serverantwort ${res.status}`);
      }
      const data = await res.json();
      const altitude = Number(data.altitudeThresholdFt);
      const speed = Number(data.speedThresholdKt);
      const timeout = Number(data.offlineTimeoutSec);
      const radius = Number(data.placeMatchRadiusMeters);
      const notificationsEnabled = !!(data && data.notificationsEnabled);
      const notifyOnTakeoff = data && Object.prototype.hasOwnProperty.call(data, "notifyOnTakeoff")
        ? data.notifyOnTakeoff !== false
        : true;
      const notifyOnLanding = data && Object.prototype.hasOwnProperty.call(data, "notifyOnLanding")
        ? data.notifyOnLanding !== false
        : true;
      const adsbHistoryAuthHeader = typeof data.adsbHistoryAuthHeader === "string"
        ? data.adsbHistoryAuthHeader
        : "";
      return {
        altitudeThresholdFt: Number.isFinite(altitude) ? altitude : 0,
        speedThresholdKt: Number.isFinite(speed) ? speed : 0,
        offlineTimeoutSec: Number.isFinite(timeout) ? timeout : 0,
        placeMatchRadiusMeters: Number.isFinite(radius) ? radius : 0,
        notificationsEnabled,
        notifyOnTakeoff,
        notifyOnLanding,
        adsbHistoryAuthHeader
      };
    }

    async function fetchPlaces() {
      const res = await fetch("/places");
      if (!res.ok) {
        throw new Error(`Serverantwort ${res.status}`);
      }
      const data = await res.json();
      return Array.isArray(data) ? data : [];
    }

    async function fetchEventsList() {
      const res = await fetch("/events");
      if (!res.ok) {
        throw new Error(`Serverantwort ${res.status}`);
      }
      const data = await res.json();
      return Array.isArray(data) ? data : [];
    }

    function getDefaultPlaceRadiusMeters() {
      const configured = currentConfigCache && currentConfigCache.placeMatchRadiusMeters;
      const parsed = parseNumberInput(configured);
      if (parsed !== null && parsed > 0) {
        return Math.round(parsed);
      }
      return DEFAULT_PLACE_RADIUS_FALLBACK_METERS;
    }

    function getPlaceRadiusInfo(place) {
      if (place && Object.prototype.hasOwnProperty.call(place, "matchRadiusMeters")) {
        const parsed = parseNumberInput(place.matchRadiusMeters);
        if (parsed !== null && parsed > 0) {
          return { value: parsed, isCustom: true };
        }
      }
      return { value: getDefaultPlaceRadiusMeters(), isCustom: false };
    }

    async function fetchAircraftList() {
      const res = await fetch("/aircraft");
      if (!res.ok) {
        throw new Error(`Serverantwort ${res.status}`);
      }
      const data = await res.json();
      return dedupeAircraftEntries(Array.isArray(data) ? data : []);
    }

    function renderPlacesTable(list) {
      const container = document.getElementById("placesList");
      const empty = document.getElementById("placesEmpty");
      if (!container || !empty) return;

      if (!Array.isArray(list) || list.length === 0) {
        container.innerHTML = "";
        empty.classList.remove("hidden");
        return;
      }

      const cards = list.map(place => {
        if (!place) return "";
        const idString = place.id !== undefined && place.id !== null ? String(place.id) : "";
        const editId = JSON.stringify(idString);
        const name = place.name !== undefined && place.name !== null ? place.name : "—";
        const type = place.type !== undefined && place.type !== null ? place.type : "—";
        const lat = escapeHtml(formatCoordinate(place.lat));
        const lon = escapeHtml(formatCoordinate(place.lon));
        const { value: placeRadiusValue, isCustom: placeRadiusCustom } = getPlaceRadiusInfo(place);
        const roundedRadius = Number.isFinite(placeRadiusValue) ? Math.round(placeRadiusValue) : placeRadiusValue;
        const radiusLabel = placeRadiusCustom
          ? `Individuell: ${roundedRadius} m`
          : `Standard (${roundedRadius} m)`;
        const radiusBadgeClass = placeRadiusCustom
          ? "rounded-2xl bg-amber-100 px-3 py-1 font-semibold text-amber-700"
          : "rounded-2xl bg-brand-frost px-3 py-1 font-semibold text-slate-600";
        const actionButtons = idString
          ? `
              <button type="button" class="inline-flex items-center justify-center rounded-full bg-brand-purple/10 px-4 py-2 text-xs font-semibold uppercase tracking-[0.3em] text-brand-purple transition duration-200 hover:bg-brand-purple/20 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/30" onclick='startEditPlace(${editId})'>Bearbeiten</button>
              <button type="button" class="inline-flex items-center justify-center rounded-full bg-rose-100 px-4 py-2 text-xs font-semibold uppercase tracking-[0.3em] text-rose-600 transition duration-200 hover:bg-rose-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-rose-300" onclick='deletePlace(${editId})'>Löschen</button>
            `
          : "";
        return `<article class="group rounded-3xl border border-slate-100/80 bg-white/80 p-4 shadow-inner shadow-white/50 transition duration-300 hover:border-brand-purple/40 hover:shadow-brand-purple/10">
            <div class="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
              <div class="flex flex-col gap-3">
                <div class="flex flex-wrap items-center gap-3">
                  <span class="text-base font-semibold text-slate-900">${escapeHtml(name)}</span>
                  <span class="rounded-full bg-brand-purple/10 px-3 py-1 text-xs font-semibold uppercase tracking-[0.3em] text-brand-purple">${escapeHtml(type)}</span>
                </div>
                <div class="flex flex-wrap gap-2 text-xs text-slate-500">
                  <span class="rounded-2xl bg-brand-frost px-3 py-1 font-semibold text-slate-600">Lat: <span class="text-brand-ink">${lat}</span></span>
                  <span class="rounded-2xl bg-brand-frost px-3 py-1 font-semibold text-slate-600">Lon: <span class="text-brand-ink">${lon}</span></span>
                  <span class="${radiusBadgeClass}">Radius: <span class="text-brand-ink">${escapeHtml(radiusLabel)}</span></span>
                </div>
              </div>
              <div class="flex flex-wrap justify-end gap-2">
                ${actionButtons}
              </div>
            </div>
          </article>`;
      }).join("");

      container.innerHTML = cards;
      empty.classList.add("hidden");
    }

    function renderAircraftList(list) {
      const container = document.getElementById("aircraftList");
      const empty = document.getElementById("aircraftEmpty");
      if (!container || !empty) return;

      const sanitizedList = dedupeAircraftEntries(Array.isArray(list) ? list : []);

      if (sanitizedList.length === 0) {
        container.innerHTML = "";
        empty.classList.remove("hidden");
        return;
      }

      const sorted = [...sanitizedList]
        .map(entry => (entry && entry.hex ? { ...entry, hex: normalizeHex(entry.hex) } : null))
        .filter(entry => entry && entry.hex)
        .sort((a, b) => {
          const nameA = (a.name || "").toLowerCase();
          const nameB = (b.name || "").toLowerCase();
          if (nameA && nameB && nameA !== nameB) {
            return nameA.localeCompare(nameB, "de");
          }
          return a.hex.localeCompare(b.hex);
        });

      const cards = sorted.map(entry => {
        const hexLabel = entry.hex ? entry.hex.toUpperCase() : "—";
        const nameLabel = entry.name ? entry.name : "";
        const description = nameLabel ? "Gespeicherter Name" : "Noch kein Name hinterlegt";
        const normalized = normalizeHex(entry.hex);
        return `<article class="group rounded-3xl border border-slate-100/80 bg-white/80 p-4 shadow-inner shadow-white/50 transition duration-300 hover:border-brand-purple/40 hover:shadow-brand-purple/10">
            <div class="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
              <div class="space-y-2">
                <h4 class="text-lg font-semibold text-slate-900">${escapeHtml(nameLabel || hexLabel)}</h4>
                <p class="text-xs font-semibold uppercase tracking-[0.3em] text-slate-400">HEX ${escapeHtml(hexLabel)}</p>
                <p class="text-xs text-slate-500">${escapeHtml(description)}</p>
              </div>
              <div class="flex flex-wrap justify-end gap-2">
                <button type="button" class="inline-flex items-center justify-center rounded-full bg-brand-purple/10 px-4 py-2 text-xs font-semibold uppercase tracking-[0.3em] text-brand-purple transition duration-200 hover:bg-brand-purple/20 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/30" onclick="startEditAircraft('${escapeHtml(normalized)}')">Umbenennen</button>
                <button type="button" class="inline-flex items-center justify-center rounded-full bg-rose-100 px-4 py-2 text-xs font-semibold uppercase tracking-[0.3em] text-rose-600 transition duration-200 hover:bg-rose-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-rose-300" onclick="removeAircraft('${escapeHtml(normalized)}')">Löschen</button>
              </div>
            </div>
          </article>`;
      }).join("");

      container.innerHTML = cards;
      empty.classList.add("hidden");
    }

    function showAircraftMessage(message, type = "") {
      const el = document.getElementById("aircraftMessage");
      if (!el) return;
      let color = "text-slate-500";
      if (type === "success") {
        color = "text-emerald-600";
      } else if (type === "error") {
        color = "text-rose-500";
      }
      el.className = `mt-4 min-h-[1.5rem] text-sm font-semibold ${color}`;
      el.textContent = message || "";
    }

    function setAircraftFormMessage(message, type = "") {
      const el = document.getElementById("aircraftFormMessage");
      if (!el) return;
      let color = "text-slate-500";
      if (type === "success") {
        color = "text-emerald-600";
      } else if (type === "error") {
        color = "text-rose-500";
      }
      el.className = `mt-4 min-h-[1.5rem] text-sm font-semibold ${color}`;
      el.textContent = message || "";
    }

    function updateAircraftFormState() {
      const form = document.getElementById("aircraftForm");
      const title = document.getElementById("aircraftFormTitle");
      const helper = document.getElementById("aircraftFormHelper");
      const display = document.getElementById("aircraftHexDisplay");
      const nameInput = document.getElementById("aircraftName");
      const submit = document.getElementById("aircraftSubmit");
      const cancel = document.getElementById("aircraftCancel");

      if (editingAircraftHex) {
        const entry = getAircraftEntry(editingAircraftHex);
        if (form) form.classList.remove("hidden");
        if (title) title.textContent = "Flugzeug umbenennen";
        if (helper) {
          helper.textContent = entry && entry.name
            ? `Aktueller Name: ${entry.name}`
            : "Vergebe einen Namen für dieses Flugzeug.";
        }
        if (display) display.textContent = editingAircraftHex.toUpperCase();
        if (nameInput) {
          nameInput.disabled = false;
          nameInput.value = entry && entry.name ? entry.name : "";
          nameInput.focus();
          nameInput.select();
        }
        if (submit) submit.disabled = false;
        if (cancel) cancel.classList.remove("hidden");
      } else {
        if (form) form.classList.add("hidden");
        if (title) title.textContent = "Flugzeug auswählen";
        if (helper) helper.textContent = "Wähle ein Flugzeug aus der Liste zum Bearbeiten.";
        if (display) display.textContent = "—";
        if (nameInput) {
          nameInput.value = "";
          nameInput.disabled = true;
        }
        if (submit) submit.disabled = true;
        if (cancel) cancel.classList.add("hidden");
      }

      setAircraftFormMessage("", "");
    }

    async function refreshAircraftList(showStatus = true) {
      try {
        const list = await fetchAircraftList();
        currentAircraft = dedupeAircraftEntries(Array.isArray(list) ? list : []);
        renderAircraftList(currentAircraft);
        if (!editingAircraftHex || !getAircraftEntry(editingAircraftHex)) {
          editingAircraftHex = null;
        }
        updateAircraftFormState();
        renderHexHistoryDropdown();
        handleHexInputChange({ skipMarkDirty: true });
        if (showStatus) {
          showAircraftMessage("Flugzeuge aktualisiert.", "success");
        } else {
          showAircraftMessage("", "");
        }
      } catch (err) {
        console.error("[Aircraft] Aktualisierung fehlgeschlagen:", err);
        const message = err && err.message ? err.message : String(err);
        showAircraftMessage(`Fehler beim Aktualisieren: ${message}`, "error");
      }
    }

    function startEditAircraft(hex) {
      const normalized = normalizeHex(hex);
      if (!normalized) {
        return;
      }
      editingAircraftHex = normalized;
      updateAircraftFormState();
    }

    function cancelAircraftEdit() {
      editingAircraftHex = null;
      updateAircraftFormState();
    }

    async function removeAircraft(hex) {
      const normalized = normalizeHex(hex);
      if (!normalized) {
        showAircraftMessage("Ungültiger Hex-Code.", "error");
        return;
      }

      const confirmed = window.confirm(`Flugzeug ${normalized.toUpperCase()} wirklich löschen?`);
      if (!confirmed) {
        return;
      }

      try {
        const res = await fetch(`/aircraft/${encodeURIComponent(normalized)}`, { method: "DELETE" });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data && data.error ? data.error : `Serverantwort ${res.status}`);
        }

        if (editingAircraftHex && normalizeHex(editingAircraftHex) === normalized) {
          editingAircraftHex = null;
        }

        await refreshAircraftList(false);
        showAircraftMessage(`Flugzeug ${normalized.toUpperCase()} gelöscht.`, "success");
        handleHexInputChange({ skipMarkDirty: true });
      } catch (err) {
        console.error("[Aircraft] Löschen fehlgeschlagen:", err);
        const message = err && err.message ? err.message : "Flugzeug konnte nicht gelöscht werden.";
        showAircraftMessage(message, "error");
      }
    }

    async function submitAircraft(event) {
      event.preventDefault();
      if (!editingAircraftHex) {
        setAircraftFormMessage("Bitte zuerst ein Flugzeug auswählen.", "error");
        return;
      }

      const nameInput = document.getElementById("aircraftName");
      const nameValue = nameInput ? nameInput.value.trim() : "";
      if (!nameValue) {
        setAircraftFormMessage("Bitte einen Namen eingeben.", "error");
        if (nameInput) nameInput.focus();
        return;
      }

      try {
        const res = await fetch(`/aircraft/${encodeURIComponent(editingAircraftHex)}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name: nameValue })
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data && data.error ? data.error : `Serverantwort ${res.status}`);
        }

        const updatedHex = normalizeHex(data && data.hex ? data.hex : editingAircraftHex);
        const updatedName = data && typeof data.name === "string" && data.name.trim()
          ? data.name.trim()
          : nameValue;

        currentAircraft = Array.isArray(currentAircraft) ? currentAircraft : [];
        currentAircraft = currentAircraft.filter(entry => normalizeHex(entry && entry.hex) !== updatedHex);
        currentAircraft.push({ ...data, hex: updatedHex, name: updatedName });
        currentAircraft = dedupeAircraftEntries(currentAircraft);

        renderAircraftList(currentAircraft);
        showAircraftMessage(`Name für ${updatedHex.toUpperCase()} gespeichert.`, "success");
        setAircraftFormMessage("Änderungen gespeichert.", "success");

        editingAircraftHex = null;
        updateAircraftFormState();
        renderHexHistoryDropdown();
        handleHexInputChange({ skipMarkDirty: true });
      } catch (err) {
        console.error("[Aircraft] Speichern fehlgeschlagen:", err);
        const message = err && err.message ? err.message : String(err);
        setAircraftFormMessage(`Fehler: ${message}`, "error");
      }
    }

    function renderEventsManagementTable(list) {
      const container = document.getElementById("eventsList");
      const empty = document.getElementById("eventsEmpty");
      if (!container || !empty) return;

      if (!Array.isArray(list) || list.length === 0) {
        container.innerHTML = "";
        empty.classList.remove("hidden");
        return;
      }

      const sorted = [...list].sort((a, b) => {
        const timeA = Date.parse(a && a.time ? a.time : 0);
        const timeB = Date.parse(b && b.time ? b.time : 0);
        const invalidA = Number.isNaN(timeA);
        const invalidB = Number.isNaN(timeB);
        if (invalidA && invalidB) return 0;
        if (invalidA) return 1;
        if (invalidB) return -1;
        return timeB - timeA;
      });

      const cards = sorted.map(event => {
        if (!event) return "";
        const eventId = event.id !== undefined && event.id !== null ? String(event.id) : "";
        const time = escapeHtml(formatDateTime(event.time));
        const typeRaw = typeof event.type === "string" ? event.type : "";
        const normalized = typeRaw.toLowerCase();
        const typeLabel = typeRaw ? typeRaw.charAt(0).toUpperCase() + typeRaw.slice(1) : "Event";
        const chipClass = normalized === "takeoff"
          ? "bg-brand-red/10 text-brand-red"
          : normalized === "landing"
            ? "bg-emerald-100 text-emerald-600"
            : "bg-brand-purple/10 text-brand-purple";
        const callsign = escapeHtml(event.callsign || event.hex || "—");
        const placeLabel = formatEventPlace(event.place, event.type);
        const action = eventId
          ? `<button type="button" class="inline-flex items-center justify-center rounded-full bg-rose-100 px-4 py-2 text-xs font-semibold uppercase tracking-[0.3em] text-rose-600 transition duration-200 hover:bg-rose-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-rose-300" onclick="deleteEventById('${escapeHtml(eventId)}')">Löschen</button>`
          : `<span class="inline-flex items-center justify-center rounded-full bg-slate-100 px-4 py-2 text-xs font-semibold uppercase tracking-[0.3em] text-slate-400">Nicht verfügbar</span>`;

        return `<article class="group rounded-3xl border border-slate-100/80 bg-white/80 p-4 shadow-inner shadow-white/50 transition duration-300 hover:border-brand-purple/40 hover:shadow-brand-purple/10">
            <div class="flex flex-wrap items-center justify-between gap-3">
              <div class="flex flex-wrap items-center gap-3">
                <span class="inline-flex items-center rounded-full ${chipClass} px-3 py-1 text-xs font-semibold uppercase tracking-[0.3em]">${escapeHtml(typeLabel)}</span>
                <span class="text-base font-semibold text-slate-900">${callsign}</span>
              </div>
              <span class="inline-flex items-center rounded-full bg-sky-100 px-3 py-1 text-xs font-semibold uppercase tracking-[0.3em] text-sky-700">${time}</span>
            </div>
            <div class="mt-3 flex flex-wrap gap-2 text-xs text-slate-500">
              <span class="rounded-2xl bg-brand-frost px-3 py-1 font-medium text-slate-600">Ort: <span class="font-semibold text-brand-ink">${placeLabel}</span></span>
            </div>
            <div class="mt-4 flex justify-end">
              ${action}
            </div>
          </article>`;
      }).join("");

      container.innerHTML = cards;
      empty.classList.add("hidden");
    }

    function showEventsSettingsMessage(message, type = "") {
      const el = document.getElementById("eventsMessage");
      if (!el) return;
      let color = "text-slate-500";
      if (type === "success") {
        color = "text-emerald-600";
      } else if (type === "error") {
        color = "text-rose-500";
      }
      el.className = `mt-4 min-h-[1.5rem] text-sm font-semibold ${color}`;
      el.textContent = message || "";
    }

    async function refreshEventsForSettings(showStatus = true) {
      try {
        const list = await fetchEventsList();
        currentEvents = Array.isArray(list) ? list : [];
        renderEventsManagementTable(currentEvents);
        if (showStatus) {
          showEventsSettingsMessage("Events aktualisiert.", "success");
        } else {
          showEventsSettingsMessage("", "");
        }
      } catch (err) {
        console.error("[Events] Aktualisierung fehlgeschlagen:", err);
        const message = err && err.message ? err.message : String(err);
        showEventsSettingsMessage(`Fehler beim Aktualisieren der Events: ${escapeHtml(message)}`, "error");
      }
    }

    async function deleteEventById(id) {
      const targetId = id !== undefined && id !== null ? String(id) : "";
      if (!targetId) {
        showEventsSettingsMessage("Ungültige Event-ID.", "error");
        return;
      }

      const confirmed = window.confirm("Dieses Event wirklich löschen?");
      if (!confirmed) return;

      try {
        const res = await fetch(`/events/${encodeURIComponent(targetId)}`, { method: "DELETE" });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data && data.error ? data.error : `Serverantwort ${res.status}`);
        }
        await refreshEventsForSettings(false);
        showEventsSettingsMessage("Event gelöscht.", "success");
      } catch (err) {
        console.error("[Events] Löschen fehlgeschlagen:", err);
        const message = err && err.message ? err.message : String(err);
        showEventsSettingsMessage(`Fehler beim Löschen: ${escapeHtml(message)}`, "error");
      }
    }

    function updatePlaceFormState() {
      const title = document.getElementById("placeFormTitle");
      const submit = document.getElementById("placeSubmit");
      const cancel = document.getElementById("placeCancel");
      const radiusRow = document.getElementById("placeRadiusRow");
      const radiusInput = document.getElementById("placeRadius");
      const radiusHelper = document.getElementById("placeRadiusHelper");
      if (title) {
        title.textContent = editingPlaceId ? "Ort bearbeiten" : "Neuen Ort hinzufügen";
      }
      if (submit) {
        submit.textContent = editingPlaceId ? "Speichern" : "Hinzufügen";
      }
      if (cancel) {
        cancel.classList.toggle("hidden", !editingPlaceId);
      }
      const defaultRadius = getDefaultPlaceRadiusMeters();
      if (radiusRow) {
        radiusRow.classList.toggle("hidden", !editingPlaceId);
      }
      if (radiusInput) {
        if (editingPlaceId) {
          radiusInput.disabled = false;
        } else {
          radiusInput.value = "";
          radiusInput.disabled = true;
        }
      }
      if (radiusHelper) {
        if (editingPlaceId) {
          radiusHelper.textContent = `Optional: Eigener Radius in Metern. Leer lassen für Standard (${defaultRadius} m).`;
        } else {
          radiusHelper.textContent = "";
        }
      }
    }

    function resetPlaceFormValues() {
      const form = document.getElementById("placeForm");
      if (form) {
        form.reset();
      }
      clearPlaceSearchResults();
      const radiusInput = document.getElementById("placeRadius");
      if (radiusInput) {
        radiusInput.value = "";
      }
    }

    function startEditPlace(id) {
      const targetId = id !== undefined && id !== null ? String(id) : "";
      if (!targetId) return;
      const place = currentPlaces.find(entry => entry && String(entry.id) === targetId);
      if (!place) return;

      editingPlaceId = targetId;
      clearPlaceSearchResults();
      const nameInput = document.getElementById("placeName");
      const typeInput = document.getElementById("placeType");
      const latInput = document.getElementById("placeLat");
      const lonInput = document.getElementById("placeLon");
      const radiusInput = document.getElementById("placeRadius");
      if (nameInput) nameInput.value = place.name !== undefined && place.name !== null ? place.name : "";
      if (typeInput) typeInput.value = place.type !== undefined && place.type !== null ? place.type : "";
      if (latInput) latInput.value = place.lat !== undefined && place.lat !== null ? place.lat : "";
      if (lonInput) lonInput.value = place.lon !== undefined && place.lon !== null ? place.lon : "";
      if (radiusInput) {
        const info = getPlaceRadiusInfo(place);
        radiusInput.value = info.isCustom && Number.isFinite(info.value) ? info.value : "";
      }

      updatePlaceFormState();
      showPlaceMessage("", "");

      const form = document.getElementById("placeForm");
      if (form && form.scrollIntoView) {
        form.scrollIntoView({ behavior: "smooth", block: "center" });
      }
    }

    function cancelPlaceEdit(resetMessage = true) {
      editingPlaceId = null;
      resetPlaceFormValues();
      updatePlaceFormState();
      if (resetMessage) {
        showPlaceMessage("", "");
      }
    }

    async function submitConfig(event) {
      event.preventDefault();

      const altitudeInput = document.getElementById("cfgAltitude");
      const speedInput = document.getElementById("cfgSpeed");
      const timeoutInput = document.getElementById("cfgTimeout");
      const radiusInput = document.getElementById("cfgRadius");
      const historyHeaderInput = document.getElementById("cfgHistoryHeader");

      const altitude = parseNumberInput(altitudeInput ? altitudeInput.value : "");
      if (altitude === null || altitude <= 0) {
        showConfigMessage("Bitte eine gültige Höhen-Schwelle größer 0 eingeben.", "error");
        return;
      }

      const speed = parseNumberInput(speedInput ? speedInput.value : "");
      if (speed === null || speed < 0) {
        showConfigMessage("Bitte eine gültige Geschwindigkeits-Schwelle eingeben.", "error");
        return;
      }

      const timeout = parseNumberInput(timeoutInput ? timeoutInput.value : "");
      if (timeout === null || timeout < 5) {
        showConfigMessage("Timeout muss mindestens 5 Sekunden betragen.", "error");
        return;
      }

      const radius = parseNumberInput(radiusInput ? radiusInput.value : "");
      if (radius === null || radius <= 0) {
        showConfigMessage("Bitte einen gültigen Radius größer 0 eingeben.", "error");
        return;
      }
      const historyHeaderRaw = historyHeaderInput ? historyHeaderInput.value : "";

      showConfigMessage("Speichere...", "");

      try {
        const payload = buildConfigRequestPayload({
          altitudeThresholdFt: altitude,
          speedThresholdKt: speed,
          offlineTimeoutSec: timeout,
          placeMatchRadiusMeters: radius,
          notificationsEnabled: notificationPreferences.enabled,
          notifyOnTakeoff: notificationPreferences.notifyOnTakeoff,
          notifyOnLanding: notificationPreferences.notifyOnLanding,
          adsbHistoryAuthHeader: historyHeaderRaw
        });
        const res = await fetch("/config", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data && data.error ? data.error : `Serverantwort ${res.status}`);
        }

        currentConfigCache = data;
        if (altitudeInput && data.altitudeThresholdFt !== undefined) {
          altitudeInput.value = data.altitudeThresholdFt;
        }
        if (speedInput && data.speedThresholdKt !== undefined) {
          speedInput.value = data.speedThresholdKt;
        }
        if (timeoutInput && data.offlineTimeoutSec !== undefined) {
          timeoutInput.value = data.offlineTimeoutSec;
        }
        if (radiusInput && data.placeMatchRadiusMeters !== undefined) {
          radiusInput.value = data.placeMatchRadiusMeters;
        }
        if (historyHeaderInput) {
          historyHeaderInput.value = typeof data.adsbHistoryAuthHeader === "string"
            ? data.adsbHistoryAuthHeader
            : "";
        }

        syncNotificationPreferencesFromConfig(data);
        updateNotificationControlsFromState();

        await refreshPlaces();
        await refreshEventsForSettings(false);
        showConfigMessage("Konfiguration gespeichert.", "success");
      } catch (err) {
        console.error("[Config] Speichern fehlgeschlagen:", err);
        showConfigMessage(`Fehler beim Speichern: ${err.message}`, "error");
      }
    }

    async function submitPlace(event) {
      event.preventDefault();

      const nameInput = document.getElementById("placeName");
      const typeInput = document.getElementById("placeType");
      const latInput = document.getElementById("placeLat");
      const lonInput = document.getElementById("placeLon");

      const name = nameInput ? nameInput.value.trim() : "";
      if (!name) {
        showPlaceMessage("Bitte einen Namen angeben.", "error");
        return;
      }

      const type = typeInput ? typeInput.value.trim() : "";
      if (!type) {
        showPlaceMessage("Bitte einen Typ angeben.", "error");
        return;
      }

      const lat = parseNumberInput(latInput ? latInput.value : "");
      if (lat === null || lat < -90 || lat > 90) {
        showPlaceMessage("Breitengrad muss zwischen -90 und 90 liegen.", "error");
        return;
      }

      const lon = parseNumberInput(lonInput ? lonInput.value : "");
      if (lon === null || lon < -180 || lon > 180) {
        showPlaceMessage("Längengrad muss zwischen -180 und 180 liegen.", "error");
        return;
      }

      const radiusInput = document.getElementById("placeRadius");
      let includeRadius = false;
      let radiusValue = null;
      if (editingPlaceId && radiusInput) {
        const rawRadius = typeof radiusInput.value === "string" ? radiusInput.value.trim() : "";
        if (rawRadius) {
          const parsedRadius = parseNumberInput(rawRadius);
          if (parsedRadius === null || parsedRadius <= 0) {
            showPlaceMessage("Radius muss größer als 0 sein.", "error");
            return;
          }
          includeRadius = true;
          radiusValue = parsedRadius;
        } else {
          includeRadius = true;
          radiusValue = null;
        }
      }

      const payload = { name, type, lat, lon };
      if (includeRadius) {
        payload.matchRadiusMeters = radiusValue;
      }
      const targetId = editingPlaceId ? encodeURIComponent(editingPlaceId) : null;
      const url = editingPlaceId ? `/places/${targetId}` : "/places";
      const method = editingPlaceId ? "PUT" : "POST";

      try {
        const res = await fetch(url, {
          method,
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data && data.error ? data.error : `Serverantwort ${res.status}`);
        }

        showPlaceMessage(editingPlaceId ? "Ort aktualisiert." : "Ort hinzugefügt.", "success");
        editingPlaceId = null;
        resetPlaceFormValues();
        updatePlaceFormState();
        await refreshPlaces();
        await refreshEventsForSettings(false);
      } catch (err) {
        console.error("[Places] Speichern fehlgeschlagen:", err);
        showPlaceMessage(`Fehler beim Speichern: ${err.message}`, "error");
      }
    }

    async function deletePlace(id) {
      const targetId = id !== undefined && id !== null ? String(id) : "";
      if (!targetId) return;

      const confirmed = window.confirm("Diesen Ort wirklich löschen?");
      if (!confirmed) return;

      try {
        const res = await fetch(`/places/${encodeURIComponent(targetId)}`, { method: "DELETE" });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data && data.error ? data.error : `Serverantwort ${res.status}`);
        }

        showPlaceMessage("Ort gelöscht.", "success");
        if (editingPlaceId && String(editingPlaceId) === targetId) {
          cancelPlaceEdit(false);
        }
        await refreshPlaces();
      } catch (err) {
        console.error("[Places] Löschen fehlgeschlagen:", err);
        showPlaceMessage(`Fehler beim Löschen: ${err.message}`, "error");
      }
    }

    async function refreshPlaces() {
      try {
        const list = await fetchPlaces();
        currentPlaces = Array.isArray(list) ? list : [];
        renderPlacesTable(currentPlaces);

        if (editingPlaceId) {
          const stillExists = currentPlaces.some(place => place && String(place.id) === String(editingPlaceId));
          if (!stillExists) {
            cancelPlaceEdit(false);
          } else {
            updatePlaceFormState();
          }
        }
      } catch (err) {
        console.error("[Places] Aktualisierung fehlgeschlagen:", err);
        showPlaceMessage(`Fehler beim Aktualisieren der Orte: ${err.message}`, "error");
      }
    }

    function updatePlaceSearchStatus(message, type = "") {
      const el = document.getElementById("placeSearchStatus");
      if (!el) return;
      let color = "text-slate-500";
      if (type === "success") {
        color = "text-emerald-600";
      } else if (type === "error") {
        color = "text-rose-500";
      }
      el.className = `mt-3 min-h-[1.5rem] text-sm font-semibold ${color}`;
      el.textContent = message || "";
    }

    function renderPlaceSearchResults(list = nominatimResults) {
      const container = document.getElementById("placeSearchResults");
      if (!container) return;

      if (!Array.isArray(list) || list.length === 0) {
        container.innerHTML = "";
        return;
      }

      const html = list.map((entry, index) => {
        if (!entry) return "";
        const isSelected = index === nominatimSelectedIndex;
        const classes = isSelected
          ? "rounded-3xl border border-brand-purple/40 bg-brand-purple/10 p-4 text-sm text-slate-600 shadow-inner shadow-brand-purple/20"
          : "rounded-3xl border border-slate-100/80 bg-white/80 p-4 text-sm text-slate-600 shadow-inner shadow-white/50";
        const typeLabel = entry.typeLabel || "";
        const classLabel = entry.classLabel || "";
        const detailParts = [];
        if (typeLabel) {
          detailParts.push(escapeHtml(typeLabel));
        }
        if (classLabel && classLabel.toLowerCase() !== typeLabel.toLowerCase()) {
          detailParts.push(escapeHtml(classLabel));
        }
        const detailHtml = detailParts.length ? `<div class="mt-1 text-xs text-slate-400">${detailParts.join(" • ")}</div>` : "";
        const coords = `${formatCoordinate(entry.lat)}, ${formatCoordinate(entry.lon)}`;
        return `<div class="${classes}">
          <div class="text-sm font-semibold text-slate-800">${escapeHtml(entry.displayName || "")}</div>
          <div class="mt-1 text-xs font-medium uppercase tracking-[0.3em] text-slate-400">${coords}</div>
          ${detailHtml}
          <button type="button" class="mt-3 inline-flex items-center justify-center rounded-2xl bg-brand-purple px-4 py-2 text-xs font-semibold uppercase tracking-[0.3em] text-white shadow-lg shadow-brand-purple/40 transition duration-300 hover:scale-[1.02] hover:bg-brand-purple/90 hover:shadow-brand-purple/60 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand-purple/60" onclick="applyNominatimResult(${index})">Koordinaten übernehmen</button>
        </div>`;
      }).join("");

      container.innerHTML = html;
    }

    function clearPlaceSearchResults() {
      nominatimResults = [];
      nominatimSelectedIndex = null;
      nominatimSearchToken += 1;
      renderPlaceSearchResults([]);
      updatePlaceSearchStatus("", "");
    }

    async function searchPlaceInOSM() {
      const input = document.getElementById("placeSearch");
      if (!input) return;

      const query = input.value ? input.value.trim() : "";
      if (!query) {
        clearPlaceSearchResults();
        updatePlaceSearchStatus("Bitte einen Suchbegriff eingeben.", "error");
        return;
      }

      const requestId = ++nominatimSearchToken;
      nominatimSelectedIndex = null;
      nominatimResults = [];
      renderPlaceSearchResults([]);
      updatePlaceSearchStatus("Suche in OpenStreetMap...", "");

      try {
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`;
        const res = await fetch(url, { headers: { "Accept": "application/json" } });
        if (!res.ok) {
          throw new Error(`Antwort ${res.status}`);
        }

        const data = await res.json();
        if (requestId !== nominatimSearchToken) {
          return;
        }

        if (!Array.isArray(data) || data.length === 0) {
          nominatimResults = [];
          renderPlaceSearchResults([]);
          updatePlaceSearchStatus("Keine Ergebnisse gefunden.", "error");
          return;
        }

        const normalized = data
          .filter(item => item && item.lat !== undefined && item.lon !== undefined)
          .map(item => {
            const lat = Number(item.lat);
            const lon = Number(item.lon);
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
              return null;
            }
            const displayName = (item.display_name || item.name || "").trim() || "Unbenannt";
            const typeLabel = item.type ? String(item.type).replace(/_/g, " ") : "";
            const classLabel = item.class ? String(item.class).replace(/_/g, " ") : "";
            return { displayName, lat, lon, typeLabel, classLabel };
          })
          .filter(Boolean);

        nominatimResults = normalized.slice(0, 10);
        if (nominatimResults.length === 0) {
          renderPlaceSearchResults([]);
          updatePlaceSearchStatus("Keine Ergebnisse gefunden.", "error");
          return;
        }

        renderPlaceSearchResults(nominatimResults);
        updatePlaceSearchStatus(`${nominatimResults.length} Ergebnis(se) gefunden.`, "success");
      } catch (err) {
        if (requestId !== nominatimSearchToken) {
          return;
        }
        console.error("[Places] OSM-Suche fehlgeschlagen:", err);
        nominatimResults = [];
        renderPlaceSearchResults([]);
        const message = err && err.message ? err.message : String(err);
        updatePlaceSearchStatus(`Suche fehlgeschlagen: ${message}`, "error");
      } finally {
        refreshLayoutAfterKeyboardInteraction();
      }
    }

    function handlePlaceSearchKey(event) {
      if (event && event.key === "Enter") {
        event.preventDefault();
        searchPlaceInOSM();
      }
    }

    function applyNominatimResult(index) {
      if (!Array.isArray(nominatimResults) || index < 0 || index >= nominatimResults.length) {
        return;
      }

      const entry = nominatimResults[index];
      const latInput = document.getElementById("placeLat");
      const lonInput = document.getElementById("placeLon");
      if (latInput) {
        latInput.value = Number.isFinite(entry.lat) ? entry.lat.toFixed(6) : entry.lat;
      }
      if (lonInput) {
        lonInput.value = Number.isFinite(entry.lon) ? entry.lon.toFixed(6) : entry.lon;
      }

      nominatimSelectedIndex = index;
      renderPlaceSearchResults();
      updatePlaceSearchStatus(`Koordinaten übernommen: ${entry.displayName}`, "success");
    }

    function showConfigMessage(message, type = "") {
      const el = document.getElementById("configMessage");
      if (!el) return;
      let color = "text-slate-500";
      if (type === "success") {
        color = "text-emerald-600";
      } else if (type === "error") {
        color = "text-rose-500";
      }
      el.className = `mt-4 min-h-[1.5rem] text-sm font-semibold ${color}`;
      el.textContent = message || "";
    }

    function showPlaceMessage(message, type = "") {
      const el = document.getElementById("placeFormMessage");
      if (!el) return;
      let color = "text-slate-500";
      if (type === "success") {
        color = "text-emerald-600";
      } else if (type === "error") {
        color = "text-rose-500";
      }
      el.className = `mt-4 min-h-[1.5rem] text-sm font-semibold ${color}`;
      el.textContent = message || "";
    }

    function handleHexInputChange(eventOrOptions) {
      const options = eventOrOptions instanceof Event
        ? { markDirty: true }
        : (typeof eventOrOptions === "object" && eventOrOptions !== null ? eventOrOptions : {});
      if (options.resetDirty) {
        hexInputDirty = false;
      } else if (options.markDirty) {
        hexInputDirty = true;
      } else if (!options.skipMarkDirty) {
        hexInputDirty = true;
      }
      const input = document.getElementById("hexInput");
      const wrapper = document.getElementById("hexNameWrapper");
      const info = document.getElementById("hexNameInfo");
      const nameInput = document.getElementById("hexNameInput");

      if (!input || !wrapper || !info || !nameInput) {
        return;
      }

      const value = normalizeHex(input.value || "");
      const entry = value ? getAircraftEntry(value) : null;

      if (!value) {
        wrapper.classList.add("hidden");
        info.classList.add("hidden");
        info.textContent = "";
        nameInput.value = "";
        return;
      }

      if (entry && entry.name) {
        info.textContent = `Gespeicherter Name: ${entry.name}`;
        info.classList.remove("hidden");
        wrapper.classList.add("hidden");
        nameInput.value = entry.name;
      } else {
        info.textContent = "Neues Flugzeug – bitte Namen vergeben.";
        info.classList.remove("hidden");
        wrapper.classList.remove("hidden");
        if (!nameInput.value.trim()) {
          nameInput.value = "";
        }
      }
    }

    function renderHexHistoryDropdown() {
      const wrapper = document.getElementById("hexHistoryWrapper");
      const select = document.getElementById("hexHistorySelect");
      if (!wrapper || !select) return;

      const list = dedupeAircraftEntries(Array.isArray(currentAircraft) ? currentAircraft : []);

      if (!Array.isArray(list) || list.length === 0) {
        wrapper.classList.add("hidden");
        select.innerHTML = "";
        return;
      }

      wrapper.classList.remove("hidden");
      const sorted = [...list]
        .map(entry => (entry && entry.hex ? { ...entry, hex: normalizeHex(entry.hex) } : null))
        .filter(entry => entry && entry.hex)
        .sort((a, b) => {
          const nameA = (a.name || "").toLowerCase();
          const nameB = (b.name || "").toLowerCase();
          if (nameA && nameB && nameA !== nameB) {
            return nameA.localeCompare(nameB, "de");
          }
          return a.hex.localeCompare(b.hex);
        });

      const options = sorted.map(entry => {
        const nameLabel = entry.name ? entry.name : "";
        const labelParts = [];
        if (nameLabel) {
          labelParts.push(nameLabel);
        }
        labelParts.push(entry.hex.toUpperCase());
        const label = labelParts.join(" • ");
        return `<option value="${escapeHtml(entry.hex)}">${escapeHtml(label)}</option>`;
      }).join("");

      select.innerHTML = `<option value="">Gespeichertes Flugzeug wählen</option>${options}`;
      select.value = "";
    }

    function handleHexHistorySelection(event) {
      const rawValue = event && event.target ? event.target.value : "";
      const value = normalizeHex(rawValue);
      if (!value) {
        return;
      }
      const input = document.getElementById("hexInput");
      if (input) {
        input.value = value;
      }
      hexInputDirty = true;
      const aircraftName = getAircraftEntry(value)?.name || "";
      if (aircraftName) {
        setHexStatus(`${aircraftName} (${value.toUpperCase()}) übernommen.`, "");
      } else {
        setHexStatus(`Hex ${value.toUpperCase()} übernommen.`, "");
      }
      if (event && event.target) {
        event.target.value = "";
      }
      handleHexInputChange({ skipMarkDirty: true });
    }

    function createStatusCard(message) {
      return `<div class="flex h-full items-center justify-center">
        <div class="view-panel max-w-md rounded-2xl bg-white/90 px-6 py-5 text-center text-base font-medium text-slate-600 shadow-card ring-1 ring-black/5 backdrop-blur">${escapeHtml(message)}</div>
      </div>`;
    }

    function escapeHtml(value) {
      if (value === null || value === undefined) return "";
      return String(value).replace(/[&<>"']/g, char => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "\"": "&quot;",
        "'": "&#39;"
      })[char] || char);
    }

    function formatCoordinate(value) {
      if (value === null || value === undefined) return "—";
      const num = Number(value);
      if (!Number.isFinite(num)) return "—";
      return num.toFixed(5);
    }

    function parseNumberInput(value) {
      if (typeof value === "number") {
        return Number.isFinite(value) ? value : null;
      }
      if (typeof value === "string") {
        const trimmed = value.trim();
        if (!trimmed) return null;
        const normalized = trimmed.replace(/\s+/g, "").replace(/,/g, ".");
        const parsed = Number(normalized);
        return Number.isFinite(parsed) ? parsed : null;
      }
      return null;
    }

  </script>
</body>
</html>
